// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/mbft/mbft.proto

package mbft

import (
	common "chainmaker.org/chainmaker-go/pb/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MBFTMessageType int32

const (
	MBFTMessageType_ProposalMessage      MBFTMessageType = 0
	MBFTMessageType_EndorseMessage       MBFTMessageType = 1
	MBFTMessageType_CommitMessage        MBFTMessageType = 2
	MBFTMessageType_PeerStateMessage     MBFTMessageType = 3
	MBFTMessageType_PeerHeartBeatMessage MBFTMessageType = 4
)

var MBFTMessageType_name = map[int32]string{
	0: "ProposalMessage",
	1: "EndorseMessage",
	2: "CommitMessage",
	3: "PeerStateMessage",
	4: "PeerHeartBeatMessage",
}

var MBFTMessageType_value = map[string]int32{
	"ProposalMessage":      0,
	"EndorseMessage":       1,
	"CommitMessage":        2,
	"PeerStateMessage":     3,
	"PeerHeartBeatMessage": 4,
}

func (x MBFTMessageType) String() string {
	return proto.EnumName(MBFTMessageType_name, int32(x))
}

func (MBFTMessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{0}
}

type MBFTConsStateType int32

const (
	MBFTConsStateType_NewHeight      MBFTConsStateType = 0
	MBFTConsStateType_NewRound       MBFTConsStateType = 1
	MBFTConsStateType_Propose        MBFTConsStateType = 2
	MBFTConsStateType_Endorse        MBFTConsStateType = 3
	MBFTConsStateType_PendingEndorse MBFTConsStateType = 4
	MBFTConsStateType_Commit         MBFTConsStateType = 5
	MBFTConsStateType_PendingCommit  MBFTConsStateType = 6
	MBFTConsStateType_Seal           MBFTConsStateType = 7
)

var MBFTConsStateType_name = map[int32]string{
	0: "NewHeight",
	1: "NewRound",
	2: "Propose",
	3: "Endorse",
	4: "PendingEndorse",
	5: "Commit",
	6: "PendingCommit",
	7: "Seal",
}

var MBFTConsStateType_value = map[string]int32{
	"NewHeight":      0,
	"NewRound":       1,
	"Propose":        2,
	"Endorse":        3,
	"PendingEndorse": 4,
	"Commit":         5,
	"PendingCommit":  6,
	"Seal":           7,
}

func (x MBFTConsStateType) String() string {
	return proto.EnumName(MBFTConsStateType_name, int32(x))
}

func (MBFTConsStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{1}
}

type MBFTQuorumCommits struct {
	BlockID []byte              `protobuf:"bytes,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	Height  uint64              `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Round   int64               `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	Level   uint64              `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	Commits []*MBFTConsensusMsg `protobuf:"bytes,5,rep,name=Commits,proto3" json:"Commits,omitempty"`
}

func (m *MBFTQuorumCommits) Reset()         { *m = MBFTQuorumCommits{} }
func (m *MBFTQuorumCommits) String() string { return proto.CompactTextString(m) }
func (*MBFTQuorumCommits) ProtoMessage()    {}
func (*MBFTQuorumCommits) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{0}
}
func (m *MBFTQuorumCommits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTQuorumCommits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTQuorumCommits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTQuorumCommits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTQuorumCommits.Merge(m, src)
}
func (m *MBFTQuorumCommits) XXX_Size() int {
	return m.Size()
}
func (m *MBFTQuorumCommits) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTQuorumCommits.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTQuorumCommits proto.InternalMessageInfo

func (m *MBFTQuorumCommits) GetBlockID() []byte {
	if m != nil {
		return m.BlockID
	}
	return nil
}

func (m *MBFTQuorumCommits) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MBFTQuorumCommits) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *MBFTQuorumCommits) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MBFTQuorumCommits) GetCommits() []*MBFTConsensusMsg {
	if m != nil {
		return m.Commits
	}
	return nil
}

type MBFTProposalMsg struct {
	Block          *common.Block `protobuf:"bytes,1,opt,name=Block,proto3" json:"Block,omitempty"`
	Height         uint64        `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Round          int64         `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	LastValidRound int64         `protobuf:"varint,4,opt,name=LastValidRound,proto3" json:"LastValidRound,omitempty"`
	Proposer       []byte        `protobuf:"bytes,5,opt,name=Proposer,proto3" json:"Proposer,omitempty"`
	ProposerIdx    int64         `protobuf:"varint,6,opt,name=ProposerIdx,proto3" json:"ProposerIdx,omitempty"`
	// MBFTConsensusInfo  LastConsInfo = 7;
	Level uint64 `protobuf:"varint,8,opt,name=Level,proto3" json:"Level,omitempty"`
}

func (m *MBFTProposalMsg) Reset()         { *m = MBFTProposalMsg{} }
func (m *MBFTProposalMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTProposalMsg) ProtoMessage()    {}
func (*MBFTProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{1}
}
func (m *MBFTProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTProposalMsg.Merge(m, src)
}
func (m *MBFTProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTProposalMsg proto.InternalMessageInfo

func (m *MBFTProposalMsg) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *MBFTProposalMsg) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MBFTProposalMsg) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *MBFTProposalMsg) GetLastValidRound() int64 {
	if m != nil {
		return m.LastValidRound
	}
	return 0
}

func (m *MBFTProposalMsg) GetProposer() []byte {
	if m != nil {
		return m.Proposer
	}
	return nil
}

func (m *MBFTProposalMsg) GetProposerIdx() int64 {
	if m != nil {
		return m.ProposerIdx
	}
	return 0
}

func (m *MBFTProposalMsg) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

type MBFTVoteMsg struct {
	BlockID    []byte `protobuf:"bytes,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	Height     uint64 `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Round      int64  `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	Author     []byte `protobuf:"bytes,4,opt,name=Author,proto3" json:"Author,omitempty"`
	AuthorIdx  int64  `protobuf:"varint,5,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
	EmptyBlock bool   `protobuf:"varint,6,opt,name=EmptyBlock,proto3" json:"EmptyBlock,omitempty"`
	Level      uint64 `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
}

func (m *MBFTVoteMsg) Reset()         { *m = MBFTVoteMsg{} }
func (m *MBFTVoteMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTVoteMsg) ProtoMessage()    {}
func (*MBFTVoteMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{2}
}
func (m *MBFTVoteMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTVoteMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTVoteMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTVoteMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTVoteMsg.Merge(m, src)
}
func (m *MBFTVoteMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTVoteMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTVoteMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTVoteMsg proto.InternalMessageInfo

func (m *MBFTVoteMsg) GetBlockID() []byte {
	if m != nil {
		return m.BlockID
	}
	return nil
}

func (m *MBFTVoteMsg) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MBFTVoteMsg) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *MBFTVoteMsg) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *MBFTVoteMsg) GetAuthorIdx() int64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *MBFTVoteMsg) GetEmptyBlock() bool {
	if m != nil {
		return m.EmptyBlock
	}
	return false
}

func (m *MBFTVoteMsg) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

type MBFTVoteStateEntry struct {
	AuthorIdx int64 `protobuf:"varint,1,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
	Result    bool  `protobuf:"varint,2,opt,name=Result,proto3" json:"Result,omitempty"`
}

func (m *MBFTVoteStateEntry) Reset()         { *m = MBFTVoteStateEntry{} }
func (m *MBFTVoteStateEntry) String() string { return proto.CompactTextString(m) }
func (*MBFTVoteStateEntry) ProtoMessage()    {}
func (*MBFTVoteStateEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{3}
}
func (m *MBFTVoteStateEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTVoteStateEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTVoteStateEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTVoteStateEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTVoteStateEntry.Merge(m, src)
}
func (m *MBFTVoteStateEntry) XXX_Size() int {
	return m.Size()
}
func (m *MBFTVoteStateEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTVoteStateEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTVoteStateEntry proto.InternalMessageInfo

func (m *MBFTVoteStateEntry) GetAuthorIdx() int64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *MBFTVoteStateEntry) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type MBFTPeerHeartBeatMsg struct {
	Height      uint64                `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	Round       int64                 `protobuf:"varint,2,opt,name=Round,proto3" json:"Round,omitempty"`
	Level       uint64                `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	State       MBFTConsStateType     `protobuf:"varint,4,opt,name=State,proto3,enum=mbft.MBFTConsStateType" json:"State,omitempty"`
	Proposal    bool                  `protobuf:"varint,5,opt,name=Proposal,proto3" json:"Proposal,omitempty"`
	Endorses    []*MBFTVoteStateEntry `protobuf:"bytes,6,rep,name=Endorses,proto3" json:"Endorses,omitempty"`
	Commits     []*MBFTVoteStateEntry `protobuf:"bytes,7,rep,name=Commits,proto3" json:"Commits,omitempty"`
	LastHeight  uint64                `protobuf:"varint,8,opt,name=LastHeight,proto3" json:"LastHeight,omitempty"`
	LastBlockID []byte                `protobuf:"bytes,9,opt,name=LastBlockID,proto3" json:"LastBlockID,omitempty"`
	LastRound   uint64                `protobuf:"varint,10,opt,name=LastRound,proto3" json:"LastRound,omitempty"`
	LastLevel   uint64                `protobuf:"varint,11,opt,name=LastLevel,proto3" json:"LastLevel,omitempty"`
	Author      []byte                `protobuf:"bytes,12,opt,name=Author,proto3" json:"Author,omitempty"`
	AuthorIdx   int64                 `protobuf:"varint,13,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
}

func (m *MBFTPeerHeartBeatMsg) Reset()         { *m = MBFTPeerHeartBeatMsg{} }
func (m *MBFTPeerHeartBeatMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTPeerHeartBeatMsg) ProtoMessage()    {}
func (*MBFTPeerHeartBeatMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{4}
}
func (m *MBFTPeerHeartBeatMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTPeerHeartBeatMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTPeerHeartBeatMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTPeerHeartBeatMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTPeerHeartBeatMsg.Merge(m, src)
}
func (m *MBFTPeerHeartBeatMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTPeerHeartBeatMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTPeerHeartBeatMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTPeerHeartBeatMsg proto.InternalMessageInfo

func (m *MBFTPeerHeartBeatMsg) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetState() MBFTConsStateType {
	if m != nil {
		return m.State
	}
	return MBFTConsStateType_NewHeight
}

func (m *MBFTPeerHeartBeatMsg) GetProposal() bool {
	if m != nil {
		return m.Proposal
	}
	return false
}

func (m *MBFTPeerHeartBeatMsg) GetEndorses() []*MBFTVoteStateEntry {
	if m != nil {
		return m.Endorses
	}
	return nil
}

func (m *MBFTPeerHeartBeatMsg) GetCommits() []*MBFTVoteStateEntry {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *MBFTPeerHeartBeatMsg) GetLastHeight() uint64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetLastBlockID() []byte {
	if m != nil {
		return m.LastBlockID
	}
	return nil
}

func (m *MBFTPeerHeartBeatMsg) GetLastRound() uint64 {
	if m != nil {
		return m.LastRound
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetLastLevel() uint64 {
	if m != nil {
		return m.LastLevel
	}
	return 0
}

func (m *MBFTPeerHeartBeatMsg) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *MBFTPeerHeartBeatMsg) GetAuthorIdx() int64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

type MBFTPeerStateMsg struct {
	Id     string `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Active bool   `protobuf:"varint,2,opt,name=Active,proto3" json:"Active,omitempty"`
}

func (m *MBFTPeerStateMsg) Reset()         { *m = MBFTPeerStateMsg{} }
func (m *MBFTPeerStateMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTPeerStateMsg) ProtoMessage()    {}
func (*MBFTPeerStateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{5}
}
func (m *MBFTPeerStateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTPeerStateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTPeerStateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTPeerStateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTPeerStateMsg.Merge(m, src)
}
func (m *MBFTPeerStateMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTPeerStateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTPeerStateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTPeerStateMsg proto.InternalMessageInfo

func (m *MBFTPeerStateMsg) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MBFTPeerStateMsg) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

type MBFTConsensusPayload struct {
	Type MBFTMessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=mbft.MBFTMessageType" json:"Type,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*MBFTConsensusPayload_ProposalMsg
	//	*MBFTConsensusPayload_VoteMsg
	//	*MBFTConsensusPayload_PeerStateMsg
	//	*MBFTConsensusPayload_PeerHeartBeatMsg
	Data isMBFTConsensusPayload_Data `protobuf_oneof:"Data"`
}

func (m *MBFTConsensusPayload) Reset()         { *m = MBFTConsensusPayload{} }
func (m *MBFTConsensusPayload) String() string { return proto.CompactTextString(m) }
func (*MBFTConsensusPayload) ProtoMessage()    {}
func (*MBFTConsensusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{6}
}
func (m *MBFTConsensusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTConsensusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTConsensusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTConsensusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTConsensusPayload.Merge(m, src)
}
func (m *MBFTConsensusPayload) XXX_Size() int {
	return m.Size()
}
func (m *MBFTConsensusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTConsensusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTConsensusPayload proto.InternalMessageInfo

type isMBFTConsensusPayload_Data interface {
	isMBFTConsensusPayload_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MBFTConsensusPayload_ProposalMsg struct {
	ProposalMsg *MBFTProposalMsg `protobuf:"bytes,2,opt,name=ProposalMsg,proto3,oneof" json:"ProposalMsg,omitempty"`
}
type MBFTConsensusPayload_VoteMsg struct {
	VoteMsg *MBFTVoteMsg `protobuf:"bytes,3,opt,name=VoteMsg,proto3,oneof" json:"VoteMsg,omitempty"`
}
type MBFTConsensusPayload_PeerStateMsg struct {
	PeerStateMsg *MBFTPeerStateMsg `protobuf:"bytes,5,opt,name=PeerStateMsg,proto3,oneof" json:"PeerStateMsg,omitempty"`
}
type MBFTConsensusPayload_PeerHeartBeatMsg struct {
	PeerHeartBeatMsg *MBFTPeerHeartBeatMsg `protobuf:"bytes,6,opt,name=PeerHeartBeatMsg,proto3,oneof" json:"PeerHeartBeatMsg,omitempty"`
}

func (*MBFTConsensusPayload_ProposalMsg) isMBFTConsensusPayload_Data()      {}
func (*MBFTConsensusPayload_VoteMsg) isMBFTConsensusPayload_Data()          {}
func (*MBFTConsensusPayload_PeerStateMsg) isMBFTConsensusPayload_Data()     {}
func (*MBFTConsensusPayload_PeerHeartBeatMsg) isMBFTConsensusPayload_Data() {}

func (m *MBFTConsensusPayload) GetData() isMBFTConsensusPayload_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MBFTConsensusPayload) GetType() MBFTMessageType {
	if m != nil {
		return m.Type
	}
	return MBFTMessageType_ProposalMessage
}

func (m *MBFTConsensusPayload) GetProposalMsg() *MBFTProposalMsg {
	if x, ok := m.GetData().(*MBFTConsensusPayload_ProposalMsg); ok {
		return x.ProposalMsg
	}
	return nil
}

func (m *MBFTConsensusPayload) GetVoteMsg() *MBFTVoteMsg {
	if x, ok := m.GetData().(*MBFTConsensusPayload_VoteMsg); ok {
		return x.VoteMsg
	}
	return nil
}

func (m *MBFTConsensusPayload) GetPeerStateMsg() *MBFTPeerStateMsg {
	if x, ok := m.GetData().(*MBFTConsensusPayload_PeerStateMsg); ok {
		return x.PeerStateMsg
	}
	return nil
}

func (m *MBFTConsensusPayload) GetPeerHeartBeatMsg() *MBFTPeerHeartBeatMsg {
	if x, ok := m.GetData().(*MBFTConsensusPayload_PeerHeartBeatMsg); ok {
		return x.PeerHeartBeatMsg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MBFTConsensusPayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MBFTConsensusPayload_ProposalMsg)(nil),
		(*MBFTConsensusPayload_VoteMsg)(nil),
		(*MBFTConsensusPayload_PeerStateMsg)(nil),
		(*MBFTConsensusPayload_PeerHeartBeatMsg)(nil),
	}
}

type MBFTConsensusMsg struct {
	Payload   *MBFTConsensusPayload    `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	SignEntry *common.EndorsementEntry `protobuf:"bytes,2,opt,name=SignEntry,proto3" json:"SignEntry,omitempty"`
}

func (m *MBFTConsensusMsg) Reset()         { *m = MBFTConsensusMsg{} }
func (m *MBFTConsensusMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTConsensusMsg) ProtoMessage()    {}
func (*MBFTConsensusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{7}
}
func (m *MBFTConsensusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTConsensusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTConsensusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTConsensusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTConsensusMsg.Merge(m, src)
}
func (m *MBFTConsensusMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTConsensusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTConsensusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTConsensusMsg proto.InternalMessageInfo

func (m *MBFTConsensusMsg) GetPayload() *MBFTConsensusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MBFTConsensusMsg) GetSignEntry() *common.EndorsementEntry {
	if m != nil {
		return m.SignEntry
	}
	return nil
}

type MBFTConsensusInfo struct {
	LastStateRoot []byte `protobuf:"bytes,1,opt,name=LastStateRoot,proto3" json:"LastStateRoot,omitempty"`
	QC            []byte `protobuf:"bytes,2,opt,name=QC,proto3" json:"QC,omitempty"`
}

func (m *MBFTConsensusInfo) Reset()         { *m = MBFTConsensusInfo{} }
func (m *MBFTConsensusInfo) String() string { return proto.CompactTextString(m) }
func (*MBFTConsensusInfo) ProtoMessage()    {}
func (*MBFTConsensusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{8}
}
func (m *MBFTConsensusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTConsensusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTConsensusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTConsensusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTConsensusInfo.Merge(m, src)
}
func (m *MBFTConsensusInfo) XXX_Size() int {
	return m.Size()
}
func (m *MBFTConsensusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTConsensusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTConsensusInfo proto.InternalMessageInfo

func (m *MBFTConsensusInfo) GetLastStateRoot() []byte {
	if m != nil {
		return m.LastStateRoot
	}
	return nil
}

func (m *MBFTConsensusInfo) GetQC() []byte {
	if m != nil {
		return m.QC
	}
	return nil
}

type MBFTRandomMsg struct {
	ConsensusData []byte `protobuf:"bytes,1,opt,name=ConsensusData,proto3" json:"ConsensusData,omitempty"`
	TxHash        []byte `protobuf:"bytes,2,opt,name=TxHash,proto3" json:"TxHash,omitempty"`
	Seed          int64  `protobuf:"varint,3,opt,name=Seed,proto3" json:"Seed,omitempty"`
}

func (m *MBFTRandomMsg) Reset()         { *m = MBFTRandomMsg{} }
func (m *MBFTRandomMsg) String() string { return proto.CompactTextString(m) }
func (*MBFTRandomMsg) ProtoMessage()    {}
func (*MBFTRandomMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f88aabc0e91f23d, []int{9}
}
func (m *MBFTRandomMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MBFTRandomMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MBFTRandomMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MBFTRandomMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MBFTRandomMsg.Merge(m, src)
}
func (m *MBFTRandomMsg) XXX_Size() int {
	return m.Size()
}
func (m *MBFTRandomMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MBFTRandomMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MBFTRandomMsg proto.InternalMessageInfo

func (m *MBFTRandomMsg) GetConsensusData() []byte {
	if m != nil {
		return m.ConsensusData
	}
	return nil
}

func (m *MBFTRandomMsg) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *MBFTRandomMsg) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func init() {
	proto.RegisterEnum("mbft.MBFTMessageType", MBFTMessageType_name, MBFTMessageType_value)
	proto.RegisterEnum("mbft.MBFTConsStateType", MBFTConsStateType_name, MBFTConsStateType_value)
	proto.RegisterType((*MBFTQuorumCommits)(nil), "mbft.MBFTQuorumCommits")
	proto.RegisterType((*MBFTProposalMsg)(nil), "mbft.MBFTProposalMsg")
	proto.RegisterType((*MBFTVoteMsg)(nil), "mbft.MBFTVoteMsg")
	proto.RegisterType((*MBFTVoteStateEntry)(nil), "mbft.MBFTVoteStateEntry")
	proto.RegisterType((*MBFTPeerHeartBeatMsg)(nil), "mbft.MBFTPeerHeartBeatMsg")
	proto.RegisterType((*MBFTPeerStateMsg)(nil), "mbft.MBFTPeerStateMsg")
	proto.RegisterType((*MBFTConsensusPayload)(nil), "mbft.MBFTConsensusPayload")
	proto.RegisterType((*MBFTConsensusMsg)(nil), "mbft.MBFTConsensusMsg")
	proto.RegisterType((*MBFTConsensusInfo)(nil), "mbft.MBFTConsensusInfo")
	proto.RegisterType((*MBFTRandomMsg)(nil), "mbft.MBFTRandomMsg")
}

func init() { proto.RegisterFile("consensus/mbft/mbft.proto", fileDescriptor_7f88aabc0e91f23d) }

var fileDescriptor_7f88aabc0e91f23d = []byte{
	// 959 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0xe3, 0x54,
	0x14, 0x8e, 0x13, 0xc7, 0x49, 0x8e, 0x93, 0x8c, 0x7b, 0x08, 0xc5, 0x44, 0x28, 0x8a, 0xcc, 0x08,
	0x95, 0x91, 0x9a, 0xa0, 0x30, 0x42, 0x02, 0xb1, 0x21, 0x9d, 0xa2, 0x04, 0x4d, 0x47, 0xed, 0x6d,
	0x35, 0x0b, 0x76, 0xb7, 0xc9, 0x9d, 0x34, 0x9a, 0xd8, 0x37, 0xd8, 0xce, 0xcc, 0x74, 0x81, 0xc4,
	0x8e, 0x2d, 0xef, 0xc0, 0x63, 0xb0, 0x42, 0x6c, 0x58, 0xce, 0x92, 0x65, 0xd5, 0xbe, 0x08, 0xba,
	0x7f, 0xb1, 0x1d, 0x8a, 0x10, 0xd2, 0x6c, 0x22, 0x9f, 0x9f, 0x7b, 0x7c, 0xbe, 0xef, 0x7c, 0xf7,
	0x38, 0xf0, 0xe1, 0x8c, 0x47, 0x09, 0x8b, 0x92, 0x4d, 0x32, 0x0c, 0x2f, 0x5f, 0xa4, 0xf2, 0x67,
	0xb0, 0x8e, 0x79, 0xca, 0xd1, 0x16, 0xcf, 0x5d, 0x9c, 0xf1, 0x30, 0xe4, 0xd1, 0xf0, 0x72, 0xc5,
	0x67, 0x2f, 0x55, 0xa4, 0xdb, 0xd1, 0xbe, 0x98, 0xfd, 0xb0, 0x61, 0x89, 0xce, 0x0f, 0x7e, 0xb5,
	0x60, 0xef, 0x64, 0xfc, 0xed, 0xc5, 0xd9, 0x86, 0xc7, 0x9b, 0xf0, 0x88, 0x87, 0xe1, 0x32, 0x4d,
	0xd0, 0x87, 0xda, 0x58, 0x1c, 0x9d, 0x3e, 0xf1, 0xad, 0xbe, 0x75, 0xd0, 0x24, 0xc6, 0xc4, 0x7d,
	0x70, 0x26, 0x6c, 0xb9, 0xb8, 0x4a, 0xfd, 0x72, 0xdf, 0x3a, 0xb0, 0x89, 0xb6, 0xb0, 0x03, 0x55,
	0xc2, 0x37, 0xd1, 0xdc, 0xaf, 0xf4, 0xad, 0x83, 0x0a, 0x51, 0x86, 0xf0, 0x3e, 0x65, 0xaf, 0xd8,
	0xca, 0xb7, 0x65, 0xb2, 0x32, 0xf0, 0x33, 0xa8, 0xe9, 0x17, 0xf9, 0xd5, 0x7e, 0xe5, 0xc0, 0x1d,
	0xed, 0x0f, 0x24, 0x02, 0xd1, 0xc7, 0x91, 0x41, 0x76, 0x92, 0x2c, 0x88, 0x49, 0x0b, 0x6e, 0x2c,
	0x78, 0x20, 0xa2, 0xa7, 0x31, 0x5f, 0xf3, 0x84, 0xae, 0x4e, 0x92, 0x05, 0x7e, 0x0c, 0x55, 0xd9,
	0x94, 0xec, 0xd0, 0x1d, 0xb5, 0x06, 0x0a, 0xdf, 0x40, 0x3a, 0x89, 0x8a, 0xfd, 0xcf, 0x76, 0x3f,
	0x81, 0xf6, 0x53, 0x9a, 0xa4, 0xcf, 0xe9, 0x6a, 0x39, 0x57, 0x61, 0x5b, 0x86, 0x77, 0xbc, 0xd8,
	0x85, 0xba, 0xea, 0x84, 0xc5, 0x7e, 0x55, 0xf2, 0xb3, 0xb5, 0xb1, 0x0f, 0xae, 0x79, 0x9e, 0xce,
	0xdf, 0xf8, 0x8e, 0x2c, 0x90, 0x77, 0x65, 0xa4, 0xd4, 0x73, 0xa4, 0x04, 0xbf, 0x5b, 0xe0, 0x0a,
	0x88, 0xcf, 0x79, 0xca, 0x04, 0xbc, 0x77, 0x35, 0x82, 0x7d, 0x70, 0xbe, 0xd9, 0xa4, 0x57, 0x3c,
	0x96, 0x58, 0x9a, 0x44, 0x5b, 0xf8, 0x11, 0x34, 0xd4, 0x93, 0xe8, 0xb2, 0x2a, 0x4f, 0x64, 0x0e,
	0xec, 0x01, 0x1c, 0x87, 0xeb, 0xf4, 0x5a, 0x31, 0x2c, 0x40, 0xd4, 0x49, 0xce, 0x93, 0x61, 0xa8,
	0xe5, 0x31, 0x7c, 0x07, 0x68, 0x20, 0x9c, 0xa7, 0x34, 0x65, 0xc7, 0x51, 0x1a, 0x5f, 0x17, 0xdf,
	0x64, 0xed, 0xbe, 0x69, 0x1f, 0x1c, 0xc2, 0x92, 0xcd, 0x4a, 0xa1, 0xa9, 0x13, 0x6d, 0x05, 0x7f,
	0x54, 0xa0, 0x23, 0x47, 0xce, 0x58, 0x3c, 0x61, 0x34, 0x4e, 0xc7, 0x8c, 0xa6, 0x82, 0x98, 0x0c,
	0xbe, 0x75, 0x3f, 0xfc, 0xf2, 0xbd, 0x0a, 0xac, 0xe4, 0x15, 0x78, 0x08, 0x55, 0xd9, 0xa0, 0xe4,
	0xa4, 0x3d, 0xfa, 0xa0, 0xa8, 0x3f, 0x19, 0xba, 0xb8, 0x5e, 0x33, 0xa2, 0xb2, 0xb2, 0x79, 0xd3,
	0x95, 0xa4, 0xaa, 0x4e, 0xb6, 0x36, 0x3e, 0x86, 0xfa, 0x71, 0x34, 0xe7, 0x71, 0xc2, 0x12, 0xdf,
	0x91, 0x6a, 0xf6, 0xb3, 0x6a, 0x45, 0x26, 0xc8, 0x36, 0x13, 0x47, 0xd9, 0x15, 0xa8, 0xfd, 0xc7,
	0x21, 0x93, 0x28, 0x66, 0x22, 0x74, 0xa8, 0xc1, 0x2b, 0xf1, 0xe4, 0x3c, 0x42, 0x79, 0xc2, 0x32,
	0xaa, 0x69, 0xc8, 0x71, 0xe7, 0x5d, 0x62, 0x12, 0xc2, 0x54, 0x34, 0x81, 0x2c, 0x90, 0x39, 0x4c,
	0x54, 0xd1, 0xe5, 0x66, 0x51, 0x45, 0x59, 0xa6, 0xa3, 0xe6, 0xbf, 0xeb, 0xa8, 0xb5, 0x33, 0xdd,
	0xe0, 0x2b, 0xf0, 0xcc, 0x10, 0x25, 0x24, 0x31, 0xc0, 0x36, 0x94, 0xa7, 0x73, 0x39, 0xbc, 0x06,
	0x29, 0x4f, 0x95, 0x42, 0x67, 0xe9, 0xf2, 0x15, 0x33, 0x0a, 0x50, 0x56, 0xf0, 0x5b, 0x59, 0x29,
	0x60, 0xbb, 0x12, 0x4e, 0xe9, 0xf5, 0x8a, 0xd3, 0x39, 0x7e, 0x0a, 0xb6, 0x98, 0x8e, 0x2c, 0xd1,
	0x1e, 0xbd, 0x9f, 0x31, 0x77, 0xc2, 0x92, 0x84, 0x2e, 0xd4, 0xe8, 0x64, 0x0a, 0x7e, 0x69, 0x6e,
	0xa3, 0xdc, 0x19, 0xf2, 0x05, 0x6e, 0xfe, 0x44, 0x2e, 0x38, 0x29, 0x91, 0x7c, 0x2e, 0x1e, 0x42,
	0x4d, 0xdf, 0x45, 0xa9, 0x1d, 0x77, 0xb4, 0x57, 0x1c, 0x91, 0x3a, 0x62, 0x72, 0xf0, 0x6b, 0x68,
	0xe6, 0x51, 0x4a, 0x9d, 0x14, 0x36, 0x5b, 0x3e, 0x3a, 0x29, 0x91, 0x42, 0x36, 0x4e, 0xc0, 0xdb,
	0x15, 0xba, 0xbc, 0x75, 0xee, 0xa8, 0x5b, 0xac, 0x90, 0xcf, 0x98, 0x94, 0xc8, 0x3f, 0x4e, 0x8d,
	0x1d, 0xb0, 0x9f, 0xd0, 0x94, 0x06, 0x3f, 0x59, 0x8a, 0xfa, 0xfc, 0x42, 0xc5, 0xc7, 0x50, 0x5b,
	0x2b, 0x12, 0xf5, 0xd6, 0xec, 0xde, 0xb3, 0x79, 0x35, 0xcd, 0xc4, 0xa4, 0xe2, 0x17, 0xd0, 0x38,
	0x5f, 0x2e, 0x22, 0x29, 0x47, 0x4d, 0xa1, 0x6f, 0xb6, 0xad, 0x56, 0x74, 0xc8, 0xa2, 0x54, 0xc9,
	0x35, 0x4b, 0x0d, 0xa6, 0xea, 0xd3, 0xb2, 0x2d, 0x3c, 0x8d, 0x5e, 0x70, 0x7c, 0x08, 0x2d, 0x21,
	0x2a, 0x89, 0x9c, 0x70, 0x9e, 0xea, 0xed, 0x56, 0x74, 0x0a, 0x8d, 0x9c, 0x1d, 0xc9, 0x77, 0x35,
	0x49, 0xf9, 0xec, 0x28, 0xa0, 0xd0, 0x12, 0xa5, 0x08, 0x8d, 0xe6, 0x3c, 0x14, 0x48, 0x1e, 0x42,
	0x6b, 0x5b, 0x57, 0xe0, 0x35, 0x65, 0x0a, 0x4e, 0x21, 0xad, 0x8b, 0x37, 0x13, 0x9a, 0x5c, 0xe9,
	0x52, 0xda, 0x42, 0x04, 0xfb, 0x9c, 0x31, 0xb3, 0x29, 0xe5, 0xf3, 0xa3, 0x1f, 0xd5, 0x27, 0x26,
	0xa7, 0x21, 0x7c, 0x0f, 0x1e, 0x6c, 0x15, 0xa1, 0xdc, 0x5e, 0x09, 0x11, 0xda, 0x1a, 0xb4, 0xf1,
	0x59, 0xb8, 0x27, 0xba, 0x11, 0xb7, 0xd4, 0xb8, 0xca, 0xd8, 0x51, 0x13, 0x55, 0x13, 0xd6, 0xde,
	0x0a, 0xfa, 0xd0, 0x29, 0x4e, 0x4c, 0x47, 0xec, 0x47, 0x3f, 0x5b, 0x19, 0x5b, 0xdb, 0x05, 0x84,
	0x2d, 0x68, 0x3c, 0x63, 0xaf, 0xd5, 0x05, 0xf7, 0x4a, 0xd8, 0x84, 0xfa, 0x33, 0xf6, 0x5a, 0x5e,
	0x57, 0xcf, 0x42, 0x17, 0x6a, 0xfa, 0xbb, 0xe2, 0x95, 0x85, 0xa1, 0xdb, 0xf2, 0x2a, 0xa2, 0xc7,
	0x53, 0x16, 0xcd, 0x97, 0xd1, 0xc2, 0xf8, 0x6c, 0x04, 0x70, 0x54, 0x8f, 0x5e, 0x55, 0xf4, 0xab,
	0xe3, 0xda, 0xe5, 0x60, 0x5d, 0x50, 0x42, 0x57, 0x5e, 0x6d, 0x3c, 0xf9, 0xf3, 0xb6, 0x67, 0xbd,
	0xbd, 0xed, 0x59, 0x37, 0xb7, 0x3d, 0xeb, 0x97, 0xbb, 0x5e, 0xe9, 0xed, 0x5d, 0xaf, 0xf4, 0xd7,
	0x5d, 0xaf, 0xf4, 0xfd, 0x60, 0x76, 0x45, 0x97, 0x51, 0x48, 0x5f, 0xb2, 0x78, 0xc0, 0xe3, 0xc5,
	0x30, 0x33, 0x0f, 0x17, 0x7c, 0xb8, 0xbe, 0x1c, 0x16, 0xff, 0x97, 0x5c, 0x3a, 0xf2, 0x3f, 0xc6,
	0xe7, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xcc, 0x5f, 0xb2, 0xb0, 0x08, 0x00, 0x00,
}

func (m *MBFTQuorumCommits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTQuorumCommits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTQuorumCommits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for iNdEx := len(m.Commits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Level != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x40
	}
	if m.ProposerIdx != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.ProposerIdx))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastValidRound != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.LastValidRound))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTVoteMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTVoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTVoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x38
	}
	if m.EmptyBlock {
		i--
		if m.EmptyBlock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x22
	}
	if m.Round != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTVoteStateEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTVoteStateEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTVoteStateEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MBFTPeerHeartBeatMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTPeerHeartBeatMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTPeerHeartBeatMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthorIdx != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x62
	}
	if m.LastLevel != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.LastLevel))
		i--
		dAtA[i] = 0x58
	}
	if m.LastRound != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.LastRound))
		i--
		dAtA[i] = 0x50
	}
	if len(m.LastBlockID) > 0 {
		i -= len(m.LastBlockID)
		copy(dAtA[i:], m.LastBlockID)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.LastBlockID)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LastHeight != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Commits) > 0 {
		for iNdEx := len(m.Commits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Endorses) > 0 {
		for iNdEx := len(m.Endorses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endorses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Proposal {
		i--
		if m.Proposal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MBFTPeerStateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTPeerStateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTPeerStateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTConsensusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTConsensusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MBFTConsensusPayload_ProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusPayload_ProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalMsg != nil {
		{
			size, err := m.ProposalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MBFTConsensusPayload_VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusPayload_VoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteMsg != nil {
		{
			size, err := m.VoteMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MBFTConsensusPayload_PeerStateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusPayload_PeerStateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PeerStateMsg != nil {
		{
			size, err := m.PeerStateMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MBFTConsensusPayload_PeerHeartBeatMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusPayload_PeerHeartBeatMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PeerHeartBeatMsg != nil {
		{
			size, err := m.PeerHeartBeatMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MBFTConsensusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTConsensusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignEntry != nil {
		{
			size, err := m.SignEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTConsensusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTConsensusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTConsensusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QC) > 0 {
		i -= len(m.QC)
		copy(dAtA[i:], m.QC)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.QC)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LastStateRoot) > 0 {
		i -= len(m.LastStateRoot)
		copy(dAtA[i:], m.LastStateRoot)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.LastStateRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MBFTRandomMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MBFTRandomMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MBFTRandomMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		i = encodeVarintMbft(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConsensusData) > 0 {
		i -= len(m.ConsensusData)
		copy(dAtA[i:], m.ConsensusData)
		i = encodeVarintMbft(dAtA, i, uint64(len(m.ConsensusData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovMbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MBFTQuorumCommits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovMbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovMbft(uint64(m.Round))
	}
	if m.Level != 0 {
		n += 1 + sovMbft(uint64(m.Level))
	}
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovMbft(uint64(l))
		}
	}
	return n
}

func (m *MBFTProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovMbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovMbft(uint64(m.Round))
	}
	if m.LastValidRound != 0 {
		n += 1 + sovMbft(uint64(m.LastValidRound))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.ProposerIdx != 0 {
		n += 1 + sovMbft(uint64(m.ProposerIdx))
	}
	if m.Level != 0 {
		n += 1 + sovMbft(uint64(m.Level))
	}
	return n
}

func (m *MBFTVoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovMbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovMbft(uint64(m.Round))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovMbft(uint64(m.AuthorIdx))
	}
	if m.EmptyBlock {
		n += 2
	}
	if m.Level != 0 {
		n += 1 + sovMbft(uint64(m.Level))
	}
	return n
}

func (m *MBFTVoteStateEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthorIdx != 0 {
		n += 1 + sovMbft(uint64(m.AuthorIdx))
	}
	if m.Result {
		n += 2
	}
	return n
}

func (m *MBFTPeerHeartBeatMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovMbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovMbft(uint64(m.Round))
	}
	if m.Level != 0 {
		n += 1 + sovMbft(uint64(m.Level))
	}
	if m.State != 0 {
		n += 1 + sovMbft(uint64(m.State))
	}
	if m.Proposal {
		n += 2
	}
	if len(m.Endorses) > 0 {
		for _, e := range m.Endorses {
			l = e.Size()
			n += 1 + l + sovMbft(uint64(l))
		}
	}
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovMbft(uint64(l))
		}
	}
	if m.LastHeight != 0 {
		n += 1 + sovMbft(uint64(m.LastHeight))
	}
	l = len(m.LastBlockID)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.LastRound != 0 {
		n += 1 + sovMbft(uint64(m.LastRound))
	}
	if m.LastLevel != 0 {
		n += 1 + sovMbft(uint64(m.LastLevel))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovMbft(uint64(m.AuthorIdx))
	}
	return n
}

func (m *MBFTPeerStateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *MBFTConsensusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMbft(uint64(m.Type))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *MBFTConsensusPayload_ProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalMsg != nil {
		l = m.ProposalMsg.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}
func (m *MBFTConsensusPayload_VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteMsg != nil {
		l = m.VoteMsg.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}
func (m *MBFTConsensusPayload_PeerStateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerStateMsg != nil {
		l = m.PeerStateMsg.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}
func (m *MBFTConsensusPayload_PeerHeartBeatMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerHeartBeatMsg != nil {
		l = m.PeerHeartBeatMsg.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}
func (m *MBFTConsensusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.SignEntry != nil {
		l = m.SignEntry.Size()
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}

func (m *MBFTConsensusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LastStateRoot)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	l = len(m.QC)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	return n
}

func (m *MBFTRandomMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsensusData)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovMbft(uint64(l))
	}
	if m.Seed != 0 {
		n += 1 + sovMbft(uint64(m.Seed))
	}
	return n
}

func sovMbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMbft(x uint64) (n int) {
	return sovMbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MBFTQuorumCommits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTQuorumCommits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTQuorumCommits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = append(m.BlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockID == nil {
				m.BlockID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &MBFTConsensusMsg{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastValidRound", wireType)
			}
			m.LastValidRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastValidRound |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = append(m.Proposer[:0], dAtA[iNdEx:postIndex]...)
			if m.Proposer == nil {
				m.Proposer = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerIdx", wireType)
			}
			m.ProposerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTVoteMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTVoteMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTVoteMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = append(m.BlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockID == nil {
				m.BlockID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyBlock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmptyBlock = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTVoteStateEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTVoteStateEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTVoteStateEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTPeerHeartBeatMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTPeerHeartBeatMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTPeerHeartBeatMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MBFTConsStateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proposal = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endorses = append(m.Endorses, &MBFTVoteStateEntry{})
			if err := m.Endorses[len(m.Endorses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &MBFTVoteStateEntry{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockID = append(m.LastBlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockID == nil {
				m.LastBlockID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRound", wireType)
			}
			m.LastRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLevel", wireType)
			}
			m.LastLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTPeerStateMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTPeerStateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTPeerStateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTConsensusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTConsensusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTConsensusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MBFTMessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MBFTProposalMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &MBFTConsensusPayload_ProposalMsg{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MBFTVoteMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &MBFTConsensusPayload_VoteMsg{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerStateMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MBFTPeerStateMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &MBFTConsensusPayload_PeerStateMsg{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerHeartBeatMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MBFTPeerHeartBeatMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &MBFTConsensusPayload_PeerHeartBeatMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTConsensusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTConsensusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTConsensusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &MBFTConsensusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignEntry == nil {
				m.SignEntry = &common.EndorsementEntry{}
			}
			if err := m.SignEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTConsensusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTConsensusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTConsensusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastStateRoot = append(m.LastStateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.LastStateRoot == nil {
				m.LastStateRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QC", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QC = append(m.QC[:0], dAtA[iNdEx:postIndex]...)
			if m.QC == nil {
				m.QC = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MBFTRandomMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MBFTRandomMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MBFTRandomMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusData = append(m.ConsensusData[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsensusData == nil {
				m.ConsensusData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMbft = fmt.Errorf("proto: unexpected end of group")
)
