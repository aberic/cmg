// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/tbft/tbft.proto

package tbft

import (
	common "chainmaker.org/chainmaker-go/pb/protogo/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TBFTMsgType defines different type message in tbft
type TBFTMsgType int32

const (
	TBFTMsgType_propose   TBFTMsgType = 0
	TBFTMsgType_prevote   TBFTMsgType = 1
	TBFTMsgType_precommit TBFTMsgType = 2
	TBFTMsgType_state     TBFTMsgType = 3
)

var TBFTMsgType_name = map[int32]string{
	0: "propose",
	1: "prevote",
	2: "precommit",
	3: "state",
}

var TBFTMsgType_value = map[string]int32{
	"propose":   0,
	"prevote":   1,
	"precommit": 2,
	"state":     3,
}

func (x TBFTMsgType) String() string {
	return proto.EnumName(TBFTMsgType_name, int32(x))
}

func (TBFTMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{0}
}

// VoteType represents the type of vote
type VoteType int32

const (
	VoteType_VotePrevote   VoteType = 0
	VoteType_VotePrecommit VoteType = 1
)

var VoteType_name = map[int32]string{
	0: "VotePrevote",
	1: "VotePrecommit",
}

var VoteType_value = map[string]int32{
	"VotePrevote":   0,
	"VotePrecommit": 1,
}

func (x VoteType) String() string {
	return proto.EnumName(VoteType_name, int32(x))
}

func (VoteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{1}
}

// Step represents the step in a round
type Step int32

const (
	Step_NewHeight     Step = 0
	Step_NewRound      Step = 1
	Step_Propose       Step = 2
	Step_Prevote       Step = 3
	Step_PrevoteWait   Step = 4
	Step_Precommit     Step = 5
	Step_PrecommitWait Step = 6
	Step_Commit        Step = 7
)

var Step_name = map[int32]string{
	0: "NewHeight",
	1: "NewRound",
	2: "Propose",
	3: "Prevote",
	4: "PrevoteWait",
	5: "Precommit",
	6: "PrecommitWait",
	7: "Commit",
}

var Step_value = map[string]int32{
	"NewHeight":     0,
	"NewRound":      1,
	"Propose":       2,
	"Prevote":       3,
	"PrevoteWait":   4,
	"Precommit":     5,
	"PrecommitWait": 6,
	"Commit":        7,
}

func (x Step) String() string {
	return proto.EnumName(Step_name, int32(x))
}

func (Step) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{2}
}

// ValidatorSet represents the set of validators
type ValidatorSet struct {
	Validators []string `protobuf:"bytes,1,rep,name=validators,proto3" json:"validators,omitempty"`
}

func (m *ValidatorSet) Reset()         { *m = ValidatorSet{} }
func (m *ValidatorSet) String() string { return proto.CompactTextString(m) }
func (*ValidatorSet) ProtoMessage()    {}
func (*ValidatorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{0}
}
func (m *ValidatorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSet.Merge(m, src)
}
func (m *ValidatorSet) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSet.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSet proto.InternalMessageInfo

func (m *ValidatorSet) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

type TBFTMsg struct {
	Type TBFTMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.TBFTMsgType" json:"type,omitempty"`
	Msg  []byte      `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *TBFTMsg) Reset()         { *m = TBFTMsg{} }
func (m *TBFTMsg) String() string { return proto.CompactTextString(m) }
func (*TBFTMsg) ProtoMessage()    {}
func (*TBFTMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{1}
}
func (m *TBFTMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TBFTMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TBFTMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TBFTMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TBFTMsg.Merge(m, src)
}
func (m *TBFTMsg) XXX_Size() int {
	return m.Size()
}
func (m *TBFTMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_TBFTMsg.DiscardUnknown(m)
}

var xxx_messageInfo_TBFTMsg proto.InternalMessageInfo

func (m *TBFTMsg) GetType() TBFTMsgType {
	if m != nil {
		return m.Type
	}
	return TBFTMsgType_propose
}

func (m *TBFTMsg) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// Proposal defined a consesensus proposal which can
// be gossiped to other node and can be serilized
// for persistent store.
type Proposal struct {
	Voter       string                   `protobuf:"bytes,1,opt,name=voter,proto3" json:"voter,omitempty"`
	Height      int64                    `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round       int32                    `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	PolRound    int32                    `protobuf:"varint,4,opt,name=pol_round,json=polRound,proto3" json:"pol_round,omitempty"`
	Block       *common.Block            `protobuf:"bytes,5,opt,name=block,proto3" json:"block,omitempty"`
	Endorsement *common.EndorsementEntry `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{2}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Proposal) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Proposal) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Proposal) GetPolRound() int32 {
	if m != nil {
		return m.PolRound
	}
	return 0
}

func (m *Proposal) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Proposal) GetEndorsement() *common.EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

// Vote represents a tbft vote
type Vote struct {
	Type        VoteType                 `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.VoteType" json:"type,omitempty"`
	Voter       string                   `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	Height      int64                    `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Round       int32                    `protobuf:"varint,4,opt,name=round,proto3" json:"round,omitempty"`
	Hash        []byte                   `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	Endorsement *common.EndorsementEntry `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{3}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetType() VoteType {
	if m != nil {
		return m.Type
	}
	return VoteType_VotePrevote
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Vote) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Vote) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Vote) GetEndorsement() *common.EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

// BlockVotes represents votes as key-value form
type BlockVotes struct {
	Votes map[string]*Vote `protobuf:"bytes,1,rep,name=votes,proto3" json:"votes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Sum   int64            `protobuf:"varint,2,opt,name=sum,proto3" json:"sum,omitempty"`
}

func (m *BlockVotes) Reset()         { *m = BlockVotes{} }
func (m *BlockVotes) String() string { return proto.CompactTextString(m) }
func (*BlockVotes) ProtoMessage()    {}
func (*BlockVotes) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{4}
}
func (m *BlockVotes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockVotes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockVotes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockVotes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockVotes.Merge(m, src)
}
func (m *BlockVotes) XXX_Size() int {
	return m.Size()
}
func (m *BlockVotes) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockVotes.DiscardUnknown(m)
}

var xxx_messageInfo_BlockVotes proto.InternalMessageInfo

func (m *BlockVotes) GetVotes() map[string]*Vote {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *BlockVotes) GetSum() int64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

// VoteSet represents a set of vote at `height` and `round`
type VoteSet struct {
	Type         VoteType               `protobuf:"varint,1,opt,name=type,proto3,enum=tbft.VoteType" json:"type,omitempty"`
	Height       int64                  `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round        int32                  `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Sum          int64                  `protobuf:"varint,4,opt,name=sum,proto3" json:"sum,omitempty"`
	Maj23        []byte                 `protobuf:"bytes,5,opt,name=maj23,proto3" json:"maj23,omitempty"`
	Votes        map[string]*Vote       `protobuf:"bytes,6,rep,name=votes,proto3" json:"votes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VotesByBlock map[string]*BlockVotes `protobuf:"bytes,7,rep,name=votes_by_block,json=votesByBlock,proto3" json:"votes_by_block,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VoteSet) Reset()         { *m = VoteSet{} }
func (m *VoteSet) String() string { return proto.CompactTextString(m) }
func (*VoteSet) ProtoMessage()    {}
func (*VoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{5}
}
func (m *VoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteSet.Merge(m, src)
}
func (m *VoteSet) XXX_Size() int {
	return m.Size()
}
func (m *VoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_VoteSet proto.InternalMessageInfo

func (m *VoteSet) GetType() VoteType {
	if m != nil {
		return m.Type
	}
	return VoteType_VotePrevote
}

func (m *VoteSet) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VoteSet) GetSum() int64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *VoteSet) GetMaj23() []byte {
	if m != nil {
		return m.Maj23
	}
	return nil
}

func (m *VoteSet) GetVotes() map[string]*Vote {
	if m != nil {
		return m.Votes
	}
	return nil
}

func (m *VoteSet) GetVotesByBlock() map[string]*BlockVotes {
	if m != nil {
		return m.VotesByBlock
	}
	return nil
}

// RoundVoteSet represents voteSet of a `round`
type RoundVoteSet struct {
	Height     int64    `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round      int32    `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Prevotes   *VoteSet `protobuf:"bytes,3,opt,name=prevotes,proto3" json:"prevotes,omitempty"`
	Precommits *VoteSet `protobuf:"bytes,4,opt,name=precommits,proto3" json:"precommits,omitempty"`
}

func (m *RoundVoteSet) Reset()         { *m = RoundVoteSet{} }
func (m *RoundVoteSet) String() string { return proto.CompactTextString(m) }
func (*RoundVoteSet) ProtoMessage()    {}
func (*RoundVoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{6}
}
func (m *RoundVoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundVoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundVoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundVoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundVoteSet.Merge(m, src)
}
func (m *RoundVoteSet) XXX_Size() int {
	return m.Size()
}
func (m *RoundVoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundVoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_RoundVoteSet proto.InternalMessageInfo

func (m *RoundVoteSet) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *RoundVoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *RoundVoteSet) GetPrevotes() *VoteSet {
	if m != nil {
		return m.Prevotes
	}
	return nil
}

func (m *RoundVoteSet) GetPrecommits() *VoteSet {
	if m != nil {
		return m.Precommits
	}
	return nil
}

// HeightRoundVoteSet represents voteSet of a `height`
type HeightRoundVoteSet struct {
	Height        int64                   `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round         int32                   `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	RoundVoteSets map[int32]*RoundVoteSet `protobuf:"bytes,3,rep,name=roundVoteSets,proto3" json:"roundVoteSets,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HeightRoundVoteSet) Reset()         { *m = HeightRoundVoteSet{} }
func (m *HeightRoundVoteSet) String() string { return proto.CompactTextString(m) }
func (*HeightRoundVoteSet) ProtoMessage()    {}
func (*HeightRoundVoteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{7}
}
func (m *HeightRoundVoteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeightRoundVoteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeightRoundVoteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeightRoundVoteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeightRoundVoteSet.Merge(m, src)
}
func (m *HeightRoundVoteSet) XXX_Size() int {
	return m.Size()
}
func (m *HeightRoundVoteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_HeightRoundVoteSet.DiscardUnknown(m)
}

var xxx_messageInfo_HeightRoundVoteSet proto.InternalMessageInfo

func (m *HeightRoundVoteSet) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *HeightRoundVoteSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *HeightRoundVoteSet) GetRoundVoteSets() map[int32]*RoundVoteSet {
	if m != nil {
		return m.RoundVoteSets
	}
	return nil
}

// ConsensusState represents the state of tbft instance
type ConsensusState struct {
	Id                 string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height             int64               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round              int32               `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Step               Step                `protobuf:"varint,4,opt,name=step,proto3,enum=tbft.Step" json:"step,omitempty"`
	Proposal           *Proposal           `protobuf:"bytes,5,opt,name=proposal,proto3" json:"proposal,omitempty"`
	VerifingProposal   *Proposal           `protobuf:"bytes,6,opt,name=verifing_proposal,json=verifingProposal,proto3" json:"verifing_proposal,omitempty"`
	LockedProposal     *Proposal           `protobuf:"bytes,7,opt,name=locked_proposal,json=lockedProposal,proto3" json:"locked_proposal,omitempty"`
	ValidProposal      *Proposal           `protobuf:"bytes,8,opt,name=valid_proposal,json=validProposal,proto3" json:"valid_proposal,omitempty"`
	HeightRoundVoteSet *HeightRoundVoteSet `protobuf:"bytes,9,opt,name=height_round_vote_set,json=heightRoundVoteSet,proto3" json:"height_round_vote_set,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{8}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

func (m *ConsensusState) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConsensusState) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ConsensusState) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ConsensusState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_NewHeight
}

func (m *ConsensusState) GetProposal() *Proposal {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *ConsensusState) GetVerifingProposal() *Proposal {
	if m != nil {
		return m.VerifingProposal
	}
	return nil
}

func (m *ConsensusState) GetLockedProposal() *Proposal {
	if m != nil {
		return m.LockedProposal
	}
	return nil
}

func (m *ConsensusState) GetValidProposal() *Proposal {
	if m != nil {
		return m.ValidProposal
	}
	return nil
}

func (m *ConsensusState) GetHeightRoundVoteSet() *HeightRoundVoteSet {
	if m != nil {
		return m.HeightRoundVoteSet
	}
	return nil
}

// GossipState represents the state of tbft instance
type GossipState struct {
	Id               string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Height           int64         `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Round            int32         `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	Step             Step          `protobuf:"varint,4,opt,name=step,proto3,enum=tbft.Step" json:"step,omitempty"`
	Proposal         []byte        `protobuf:"bytes,5,opt,name=proposal,proto3" json:"proposal,omitempty"`
	VerifingProposal []byte        `protobuf:"bytes,6,opt,name=verifing_proposal,json=verifingProposal,proto3" json:"verifing_proposal,omitempty"`
	RoundVoteSet     *RoundVoteSet `protobuf:"bytes,7,opt,name=round_vote_set,json=roundVoteSet,proto3" json:"round_vote_set,omitempty"`
}

func (m *GossipState) Reset()         { *m = GossipState{} }
func (m *GossipState) String() string { return proto.CompactTextString(m) }
func (*GossipState) ProtoMessage()    {}
func (*GossipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3dacd5877ec4420d, []int{9}
}
func (m *GossipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GossipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GossipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipState.Merge(m, src)
}
func (m *GossipState) XXX_Size() int {
	return m.Size()
}
func (m *GossipState) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipState.DiscardUnknown(m)
}

var xxx_messageInfo_GossipState proto.InternalMessageInfo

func (m *GossipState) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GossipState) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *GossipState) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *GossipState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step_NewHeight
}

func (m *GossipState) GetProposal() []byte {
	if m != nil {
		return m.Proposal
	}
	return nil
}

func (m *GossipState) GetVerifingProposal() []byte {
	if m != nil {
		return m.VerifingProposal
	}
	return nil
}

func (m *GossipState) GetRoundVoteSet() *RoundVoteSet {
	if m != nil {
		return m.RoundVoteSet
	}
	return nil
}

func init() {
	proto.RegisterEnum("tbft.TBFTMsgType", TBFTMsgType_name, TBFTMsgType_value)
	proto.RegisterEnum("tbft.VoteType", VoteType_name, VoteType_value)
	proto.RegisterEnum("tbft.Step", Step_name, Step_value)
	proto.RegisterType((*ValidatorSet)(nil), "tbft.ValidatorSet")
	proto.RegisterType((*TBFTMsg)(nil), "tbft.TBFTMsg")
	proto.RegisterType((*Proposal)(nil), "tbft.Proposal")
	proto.RegisterType((*Vote)(nil), "tbft.Vote")
	proto.RegisterType((*BlockVotes)(nil), "tbft.BlockVotes")
	proto.RegisterMapType((map[string]*Vote)(nil), "tbft.BlockVotes.VotesEntry")
	proto.RegisterType((*VoteSet)(nil), "tbft.VoteSet")
	proto.RegisterMapType((map[string]*BlockVotes)(nil), "tbft.VoteSet.VotesByBlockEntry")
	proto.RegisterMapType((map[string]*Vote)(nil), "tbft.VoteSet.VotesEntry")
	proto.RegisterType((*RoundVoteSet)(nil), "tbft.RoundVoteSet")
	proto.RegisterType((*HeightRoundVoteSet)(nil), "tbft.HeightRoundVoteSet")
	proto.RegisterMapType((map[int32]*RoundVoteSet)(nil), "tbft.HeightRoundVoteSet.RoundVoteSetsEntry")
	proto.RegisterType((*ConsensusState)(nil), "tbft.ConsensusState")
	proto.RegisterType((*GossipState)(nil), "tbft.GossipState")
}

func init() { proto.RegisterFile("consensus/tbft/tbft.proto", fileDescriptor_3dacd5877ec4420d) }

var fileDescriptor_3dacd5877ec4420d = []byte{
	// 943 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x8b, 0x23, 0x45,
	0x14, 0x4f, 0xa5, 0x3b, 0x5f, 0x2f, 0x3d, 0xbd, 0x3d, 0xc5, 0x2a, 0x6d, 0x16, 0x62, 0x88, 0x28,
	0x71, 0x96, 0xed, 0x60, 0x16, 0x75, 0x59, 0x4f, 0x66, 0x1d, 0x15, 0xc4, 0x65, 0xb6, 0x67, 0x58,
	0xc1, 0x4b, 0xe8, 0x4c, 0x6a, 0x93, 0x76, 0x92, 0xae, 0xb6, 0xab, 0x92, 0x25, 0xe0, 0x1f, 0x21,
	0x28, 0xfa, 0xdf, 0x78, 0xf6, 0xe0, 0x61, 0x8f, 0x1e, 0x65, 0xe6, 0x28, 0xf8, 0x37, 0x48, 0x7d,
	0xf4, 0x47, 0x26, 0x3d, 0xe0, 0xb2, 0xb2, 0x97, 0x50, 0xef, 0xfb, 0xbd, 0xdf, 0xef, 0x55, 0x57,
	0xe0, 0xad, 0x73, 0x1a, 0x31, 0x12, 0xb1, 0x35, 0x1b, 0xf2, 0xe9, 0x33, 0x2e, 0x7f, 0xbc, 0x38,
	0xa1, 0x9c, 0x62, 0x53, 0x9c, 0x3b, 0xf8, 0x9c, 0xae, 0x56, 0x34, 0x1a, 0x4e, 0x97, 0xf4, 0xfc,
	0x42, 0x59, 0x3a, 0xb7, 0xb5, 0x2e, 0x21, 0xdf, 0xaf, 0x09, 0xd3, 0xfe, 0x7d, 0x0f, 0xac, 0xa7,
	0xc1, 0x32, 0x9c, 0x05, 0x9c, 0x26, 0xa7, 0x84, 0xe3, 0x2e, 0xc0, 0x26, 0x95, 0x99, 0x8b, 0x7a,
	0xc6, 0xa0, 0xe5, 0x17, 0x34, 0xfd, 0x31, 0x34, 0xce, 0xc6, 0x9f, 0x9f, 0x7d, 0xcd, 0xe6, 0xf8,
	0x5d, 0x30, 0xf9, 0x36, 0x26, 0x2e, 0xea, 0xa1, 0x81, 0x3d, 0x3a, 0xf4, 0x64, 0x17, 0xda, 0x78,
	0xb6, 0x8d, 0x89, 0x2f, 0xcd, 0xd8, 0x01, 0x63, 0xc5, 0xe6, 0x6e, 0xb5, 0x87, 0x06, 0x96, 0x2f,
	0x8e, 0xfd, 0x3f, 0x10, 0x34, 0x4f, 0x12, 0x1a, 0x53, 0x16, 0x2c, 0xf1, 0x6d, 0xa8, 0x6d, 0x28,
	0x27, 0x89, 0x4c, 0xd3, 0xf2, 0x95, 0x80, 0xdf, 0x84, 0xfa, 0x82, 0x84, 0xf3, 0x05, 0x97, 0x71,
	0x86, 0xaf, 0x25, 0xe1, 0x9d, 0xd0, 0x75, 0x34, 0x73, 0x8d, 0x1e, 0x1a, 0xd4, 0x7c, 0x25, 0xe0,
	0x3b, 0xd0, 0x8a, 0xe9, 0x72, 0xa2, 0x2c, 0xa6, 0xb4, 0x34, 0x63, 0xba, 0xf4, 0xa5, 0xf1, 0x1d,
	0xa8, 0x49, 0x18, 0xdc, 0x5a, 0x0f, 0x0d, 0xda, 0xa3, 0x03, 0x4f, 0xe1, 0xe0, 0x8d, 0x85, 0xd2,
	0x57, 0x36, 0xfc, 0x10, 0xda, 0x24, 0x9a, 0xd1, 0x84, 0x91, 0x15, 0x89, 0xb8, 0x5b, 0x97, 0xae,
	0x6e, 0xea, 0x7a, 0x9c, 0x9b, 0x8e, 0x23, 0x9e, 0x6c, 0xfd, 0xa2, 0x73, 0xff, 0x37, 0x04, 0xe6,
	0x53, 0xca, 0x09, 0xee, 0xef, 0x00, 0x62, 0x2b, 0x40, 0x84, 0xa5, 0x80, 0x46, 0x36, 0x6e, 0xb5,
	0x7c, 0x5c, 0xa3, 0x7c, 0x5c, 0xb3, 0x38, 0x2e, 0x06, 0x73, 0x11, 0xb0, 0x85, 0x1c, 0xc8, 0xf2,
	0xe5, 0xf9, 0x95, 0x06, 0xf8, 0x15, 0x01, 0x48, 0x34, 0x44, 0xaf, 0x0c, 0x7f, 0xa0, 0x5a, 0x54,
	0xec, 0xb7, 0x47, 0x77, 0xd4, 0x1c, 0xb9, 0x83, 0x1c, 0x89, 0xa9, 0x3c, 0xca, 0x53, 0x70, 0xcc,
	0xd6, 0x2b, 0xcd, 0x95, 0x38, 0x76, 0x3e, 0x03, 0xc8, 0xdd, 0x84, 0xfd, 0x82, 0x6c, 0x35, 0xc5,
	0xe2, 0x88, 0x7b, 0x50, 0xdb, 0x04, 0xcb, 0x35, 0x91, 0x31, 0xed, 0x11, 0xe4, 0x60, 0xf9, 0xca,
	0xf0, 0xb0, 0xfa, 0x00, 0xf5, 0x7f, 0x32, 0xa0, 0x21, 0x74, 0x62, 0x33, 0xff, 0x0b, 0xba, 0x2f,
	0xb7, 0x36, 0xba, 0x6b, 0x33, 0xeb, 0x5a, 0xf8, 0xad, 0x82, 0xef, 0x46, 0xf7, 0x35, 0xb4, 0x4a,
	0xc0, 0x5e, 0x0a, 0x48, 0x5d, 0x02, 0xe2, 0xe6, 0xa5, 0x4f, 0x09, 0x2f, 0x41, 0xe3, 0x18, 0x6c,
	0x79, 0x98, 0x4c, 0xb7, 0x13, 0xb5, 0x7a, 0x0d, 0x19, 0xf8, 0x76, 0x49, 0xe0, 0x78, 0x2b, 0x81,
	0x55, 0xf1, 0xd6, 0xa6, 0xa0, 0xfa, 0x7f, 0x20, 0xec, 0x3c, 0x81, 0xc3, 0xbd, 0x42, 0x25, 0xc9,
	0xde, 0xdb, 0x4d, 0xe6, 0x5c, 0x27, 0xbd, 0xc8, 0xca, 0x2f, 0x08, 0x2c, 0x79, 0xb7, 0x52, 0x6a,
	0x72, 0xd8, 0x51, 0x39, 0xec, 0xd5, 0x22, 0xec, 0xef, 0x43, 0x33, 0x4e, 0x88, 0x42, 0xd4, 0xd0,
	0x77, 0xb2, 0x08, 0x8c, 0x9f, 0x99, 0xf1, 0x3d, 0x80, 0x38, 0x21, 0x62, 0x89, 0x43, 0xce, 0x24,
	0x51, 0x7b, 0xce, 0x05, 0x87, 0xfe, 0xdf, 0x08, 0xf0, 0x97, 0xb2, 0xf4, 0x2b, 0xb4, 0xf7, 0x04,
	0x0e, 0x92, 0x42, 0xb4, 0xe8, 0x51, 0x90, 0x77, 0x57, 0x95, 0xdd, 0x4f, 0xef, 0x15, 0x05, 0xbd,
	0x08, 0xbb, 0x19, 0x3a, 0x67, 0x80, 0xf7, 0x9d, 0x8a, 0x24, 0xd4, 0x14, 0x09, 0x83, 0x5d, 0x12,
	0xb0, 0x2a, 0x59, 0x0c, 0x2d, 0xd2, 0xf0, 0xb3, 0x01, 0xf6, 0xa3, 0xf4, 0x21, 0x38, 0xe5, 0x01,
	0x27, 0xd8, 0x86, 0x6a, 0x38, 0xd3, 0xb4, 0x56, 0xc3, 0xd9, 0x4b, 0xde, 0x87, 0x2e, 0x98, 0x8c,
	0x93, 0x58, 0xe2, 0x6c, 0xa7, 0xfb, 0x74, 0xca, 0x49, 0xec, 0x4b, 0x3d, 0x3e, 0x12, 0xc4, 0xa9,
	0xcf, 0xb6, 0xfe, 0x98, 0xea, 0x5b, 0x98, 0x7e, 0xcc, 0xfd, 0xcc, 0x8e, 0x3f, 0x81, 0xc3, 0x0d,
	0x49, 0xc2, 0x67, 0x61, 0x34, 0x9f, 0x64, 0x41, 0xf5, 0xd2, 0x20, 0x27, 0x75, 0xcc, 0xde, 0x84,
	0x8f, 0xe1, 0x96, 0x58, 0x3c, 0x32, 0xcb, 0x43, 0x1b, 0xa5, 0xa1, 0xb6, 0x72, 0xcb, 0x02, 0x3f,
	0x04, 0x5b, 0xbe, 0x55, 0x79, 0x5c, 0xb3, 0x34, 0xee, 0x40, 0x7a, 0x65, 0x61, 0x5f, 0xc1, 0x1b,
	0x0a, 0x18, 0xf5, 0x84, 0x4c, 0xc4, 0xf2, 0x4d, 0x18, 0xe1, 0x6e, 0x4b, 0x7f, 0x46, 0x6f, 0xa0,
	0xde, 0xc7, 0x8b, 0x3d, 0x5d, 0xff, 0x1f, 0x04, 0xed, 0x2f, 0x28, 0x63, 0x61, 0xfc, 0x3a, 0x38,
	0xe9, 0x5c, 0xe3, 0xc4, 0x2a, 0x70, 0x70, 0xf7, 0x26, 0x0e, 0xac, 0x12, 0xcc, 0x1f, 0x80, 0x7d,
	0x6d, 0xf8, 0xc6, 0x8d, 0x4b, 0x68, 0x15, 0xd7, 0xfb, 0xe8, 0x53, 0x68, 0x17, 0x5e, 0x7d, 0xdc,
	0x86, 0x86, 0x2a, 0x46, 0x9c, 0x8a, 0x12, 0xe4, 0x65, 0x76, 0x10, 0x3e, 0x80, 0x56, 0x76, 0x59,
	0x9d, 0x2a, 0x6e, 0x41, 0x8d, 0x09, 0x84, 0x1c, 0xe3, 0xc8, 0x83, 0x66, 0xfa, 0x25, 0xc7, 0xb7,
	0xa0, 0x2d, 0xce, 0x27, 0x3a, 0xac, 0x82, 0x0f, 0xe1, 0x40, 0x2b, 0x74, 0x28, 0x3a, 0xfa, 0x01,
	0x4c, 0x81, 0x81, 0xc8, 0xf8, 0x98, 0x3c, 0x57, 0xc4, 0x38, 0x15, 0x6c, 0x41, 0xf3, 0x31, 0x79,
	0x2e, 0x5b, 0x75, 0x90, 0xa8, 0x7d, 0xa2, 0x1b, 0xa9, 0x2a, 0x41, 0x65, 0x34, 0x44, 0x09, 0x2d,
	0x7c, 0x13, 0x84, 0xdc, 0x31, 0x45, 0x9e, 0x3c, 0x7d, 0x4d, 0x54, 0xcc, 0x44, 0xe9, 0x51, 0xc7,
	0x00, 0xf5, 0x47, 0xca, 0xdc, 0x18, 0x9f, 0xfc, 0x7e, 0xd9, 0x45, 0x2f, 0x2e, 0xbb, 0xe8, 0xaf,
	0xcb, 0x2e, 0xfa, 0xf1, 0xaa, 0x5b, 0x79, 0x71, 0xd5, 0xad, 0xfc, 0x79, 0xd5, 0xad, 0x7c, 0xfb,
	0xd1, 0xf9, 0x22, 0x08, 0xa3, 0x55, 0x70, 0x41, 0x12, 0x8f, 0x26, 0xf3, 0x61, 0x2e, 0xde, 0x9b,
	0xd3, 0x61, 0x3c, 0x1d, 0xca, 0x3f, 0x5d, 0x73, 0x3a, 0xdc, 0xfd, 0x03, 0x37, 0xad, 0x4b, 0xfd,
	0xfd, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xcc, 0x93, 0x58, 0x3d, 0xd9, 0x09, 0x00, 0x00,
}

func (m *ValidatorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTbft(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TBFTMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TBFTMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TBFTMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Endorsement != nil {
		{
			size, err := m.Endorsement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PolRound != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.PolRound))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Endorsement != nil {
		{
			size, err := m.Endorsement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockVotes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockVotes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockVotes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Sum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Votes) > 0 {
		for k := range m.Votes {
			v := m.Votes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VotesByBlock) > 0 {
		for k := range m.VotesByBlock {
			v := m.VotesByBlock[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Votes) > 0 {
		for k := range m.Votes {
			v := m.Votes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTbft(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Maj23) > 0 {
		i -= len(m.Maj23)
		copy(dAtA[i:], m.Maj23)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Maj23)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Sum != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Sum))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundVoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundVoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundVoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precommits != nil {
		{
			size, err := m.Precommits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Prevotes != nil {
		{
			size, err := m.Prevotes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeightRoundVoteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeightRoundVoteSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeightRoundVoteSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoundVoteSets) > 0 {
		for k := range m.RoundVoteSets {
			v := m.RoundVoteSets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTbft(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintTbft(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeightRoundVoteSet != nil {
		{
			size, err := m.HeightRoundVoteSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ValidProposal != nil {
		{
			size, err := m.ValidProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LockedProposal != nil {
		{
			size, err := m.LockedProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.VerifingProposal != nil {
		{
			size, err := m.VerifingProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Proposal != nil {
		{
			size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Step != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GossipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoundVoteSet != nil {
		{
			size, err := m.RoundVoteSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VerifingProposal) > 0 {
		i -= len(m.VerifingProposal)
		copy(dAtA[i:], m.VerifingProposal)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.VerifingProposal)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Proposal) > 0 {
		i -= len(m.Proposal)
		copy(dAtA[i:], m.Proposal)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Proposal)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Step != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintTbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTbft(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovTbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ValidatorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTbft(uint64(l))
		}
	}
	return n
}

func (m *TBFTMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.PolRound != 0 {
		n += 1 + sovTbft(uint64(m.PolRound))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Endorsement != nil {
		l = m.Endorsement.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Endorsement != nil {
		l = m.Endorsement.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *BlockVotes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Votes) > 0 {
		for k, v := range m.Votes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	if m.Sum != 0 {
		n += 1 + sovTbft(uint64(m.Sum))
	}
	return n
}

func (m *VoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTbft(uint64(m.Type))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Sum != 0 {
		n += 1 + sovTbft(uint64(m.Sum))
	}
	l = len(m.Maj23)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if len(m.Votes) > 0 {
		for k, v := range m.Votes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	if len(m.VotesByBlock) > 0 {
		for k, v := range m.VotesByBlock {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTbft(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RoundVoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Prevotes != nil {
		l = m.Prevotes.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Precommits != nil {
		l = m.Precommits.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *HeightRoundVoteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if len(m.RoundVoteSets) > 0 {
		for k, v := range m.RoundVoteSets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTbft(uint64(l))
			}
			mapEntrySize := 1 + sovTbft(uint64(k)) + l
			n += mapEntrySize + 1 + sovTbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovTbft(uint64(m.Step))
	}
	if m.Proposal != nil {
		l = m.Proposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.VerifingProposal != nil {
		l = m.VerifingProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.LockedProposal != nil {
		l = m.LockedProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.ValidProposal != nil {
		l = m.ValidProposal.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.HeightRoundVoteSet != nil {
		l = m.HeightRoundVoteSet.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func (m *GossipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTbft(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovTbft(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovTbft(uint64(m.Step))
	}
	l = len(m.Proposal)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	l = len(m.VerifingProposal)
	if l > 0 {
		n += 1 + l + sovTbft(uint64(l))
	}
	if m.RoundVoteSet != nil {
		l = m.RoundVoteSet.Size()
		n += 1 + l + sovTbft(uint64(l))
	}
	return n
}

func sovTbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTbft(x uint64) (n int) {
	return sovTbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ValidatorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TBFTMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TBFTMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TBFTMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TBFTMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolRound", wireType)
			}
			m.PolRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PolRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endorsement == nil {
				m.Endorsement = &common.EndorsementEntry{}
			}
			if err := m.Endorsement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endorsement == nil {
				m.Endorsement = &common.EndorsementEntry{}
			}
			if err := m.Endorsement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockVotes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockVotes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockVotes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Votes == nil {
				m.Votes = make(map[string]*Vote)
			}
			var mapkey string
			var mapvalue *Vote
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Vote{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Votes[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VoteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maj23", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maj23 = append(m.Maj23[:0], dAtA[iNdEx:postIndex]...)
			if m.Maj23 == nil {
				m.Maj23 = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Votes == nil {
				m.Votes = make(map[string]*Vote)
			}
			var mapkey string
			var mapvalue *Vote
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Vote{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Votes[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotesByBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VotesByBlock == nil {
				m.VotesByBlock = make(map[string]*BlockVotes)
			}
			var mapkey string
			var mapvalue *BlockVotes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTbft
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BlockVotes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VotesByBlock[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundVoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundVoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundVoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prevotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prevotes == nil {
				m.Prevotes = &VoteSet{}
			}
			if err := m.Prevotes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precommits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Precommits == nil {
				m.Precommits = &VoteSet{}
			}
			if err := m.Precommits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeightRoundVoteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeightRoundVoteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeightRoundVoteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundVoteSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoundVoteSets == nil {
				m.RoundVoteSets = make(map[int32]*RoundVoteSet)
			}
			var mapkey int32
			var mapvalue *RoundVoteSet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoundVoteSet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoundVoteSets[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proposal == nil {
				m.Proposal = &Proposal{}
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifingProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifingProposal == nil {
				m.VerifingProposal = &Proposal{}
			}
			if err := m.VerifingProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockedProposal == nil {
				m.LockedProposal = &Proposal{}
			}
			if err := m.LockedProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidProposal == nil {
				m.ValidProposal = &Proposal{}
			}
			if err := m.ValidProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightRoundVoteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeightRoundVoteSet == nil {
				m.HeightRoundVoteSet = &HeightRoundVoteSet{}
			}
			if err := m.HeightRoundVoteSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= Step(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposal = append(m.Proposal[:0], dAtA[iNdEx:postIndex]...)
			if m.Proposal == nil {
				m.Proposal = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifingProposal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifingProposal = append(m.VerifingProposal[:0], dAtA[iNdEx:postIndex]...)
			if m.VerifingProposal == nil {
				m.VerifingProposal = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundVoteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoundVoteSet == nil {
				m.RoundVoteSet = &RoundVoteSet{}
			}
			if err := m.RoundVoteSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTbft = fmt.Errorf("proto: unexpected end of group")
)
