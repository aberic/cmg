// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/contract.proto

package common

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContractName int32

const (
	// system chain configuration contract
	// used to add, delete and change the chain configuration
	ContractName_SYSTEM_CONTRACT_CHAIN_CONFIG ContractName = 0
	// system chain query contract
	// used to query the configuration on the chain
	ContractName_SYSTEM_CONTRACT_QUERY ContractName = 1
	// system certificate storage contract
	// used to manage certificates
	ContractName_SYSTEM_CONTRACT_CERT_MANAGE ContractName = 2
	// governance contract
	ContractName_SYSTEM_CONTRACT_GOVERNANCE ContractName = 3
	// multi signature contract on chain
	ContractName_SYSTEM_CONTRACT_MULTI_SIGN ContractName = 4
	// contract state
	ContractName_SYSTEM_CONTRACT_STATE ContractName = 5
	// private compute contract
	ContractName_SYSTEM_CONTRACT_PRIVATE_COMPUTE ContractName = 6
)

var ContractName_name = map[int32]string{
	0: "SYSTEM_CONTRACT_CHAIN_CONFIG",
	1: "SYSTEM_CONTRACT_QUERY",
	2: "SYSTEM_CONTRACT_CERT_MANAGE",
	3: "SYSTEM_CONTRACT_GOVERNANCE",
	4: "SYSTEM_CONTRACT_MULTI_SIGN",
	5: "SYSTEM_CONTRACT_STATE",
	6: "SYSTEM_CONTRACT_PRIVATE_COMPUTE",
}

var ContractName_value = map[string]int32{
	"SYSTEM_CONTRACT_CHAIN_CONFIG":    0,
	"SYSTEM_CONTRACT_QUERY":           1,
	"SYSTEM_CONTRACT_CERT_MANAGE":     2,
	"SYSTEM_CONTRACT_GOVERNANCE":      3,
	"SYSTEM_CONTRACT_MULTI_SIGN":      4,
	"SYSTEM_CONTRACT_STATE":           5,
	"SYSTEM_CONTRACT_PRIVATE_COMPUTE": 6,
}

func (x ContractName) String() string {
	return proto.EnumName(ContractName_name, int32(x))
}

func (ContractName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}

type QueryFunction int32

const (
	// get block by transactionId
	QueryFunction_GET_BLOCK_BY_TX_ID QueryFunction = 0
	// get contract information
	QueryFunction_GET_CONTRACT_INFO QueryFunction = 1
	// get transaction by transactionId
	QueryFunction_GET_TX_BY_TX_ID QueryFunction = 2
	// get block by block height
	QueryFunction_GET_BLOCK_BY_HEIGHT QueryFunction = 3
	// get chain information
	QueryFunction_GET_CHAIN_INFO QueryFunction = 4
	// get the last configuration block
	QueryFunction_GET_LAST_CONFIG_BLOCK QueryFunction = 5
	// get block by block hash
	QueryFunction_GET_BLOCK_BY_HASH QueryFunction = 6
	// get the list of node
	QueryFunction_GET_NODE_CHAIN_LIST QueryFunction = 7
	// get governance information
	QueryFunction_GET_GOVERNANCE_CONTRACT QueryFunction = 8
	// get read/write set information by eight
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT QueryFunction = 9
	// get read/write set information by hash
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HASH QueryFunction = 10
	// get the last block
	QueryFunction_GET_LAST_BLOCK QueryFunction = 11
)

var QueryFunction_name = map[int32]string{
	0:  "GET_BLOCK_BY_TX_ID",
	1:  "GET_CONTRACT_INFO",
	2:  "GET_TX_BY_TX_ID",
	3:  "GET_BLOCK_BY_HEIGHT",
	4:  "GET_CHAIN_INFO",
	5:  "GET_LAST_CONFIG_BLOCK",
	6:  "GET_BLOCK_BY_HASH",
	7:  "GET_NODE_CHAIN_LIST",
	8:  "GET_GOVERNANCE_CONTRACT",
	9:  "GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT",
	10: "GET_BLOCK_WITH_TXRWSETS_BY_HASH",
	11: "GET_LAST_BLOCK",
}

var QueryFunction_value = map[string]int32{
	"GET_BLOCK_BY_TX_ID":                0,
	"GET_CONTRACT_INFO":                 1,
	"GET_TX_BY_TX_ID":                   2,
	"GET_BLOCK_BY_HEIGHT":               3,
	"GET_CHAIN_INFO":                    4,
	"GET_LAST_CONFIG_BLOCK":             5,
	"GET_BLOCK_BY_HASH":                 6,
	"GET_NODE_CHAIN_LIST":               7,
	"GET_GOVERNANCE_CONTRACT":           8,
	"GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT": 9,
	"GET_BLOCK_WITH_TXRWSETS_BY_HASH":   10,
	"GET_LAST_BLOCK":                    11,
}

func (x QueryFunction) String() string {
	return proto.EnumName(QueryFunction_name, int32(x))
}

func (QueryFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}

// smart contract runtime, contains vm type and language type
type RuntimeType int32

const (
	RuntimeType_INVALID RuntimeType = 0
	// native implement in chainmaker-go
	RuntimeType_NATIVE RuntimeType = 1
	// vm-wasmer, language-c++
	RuntimeType_WASMER RuntimeType = 2
	// vm-wxvm, language-cpp
	RuntimeType_WXVM RuntimeType = 3
	// wasm interpreter in go
	RuntimeType_GASM RuntimeType = 4
	// vm-evm
	RuntimeType_EVM RuntimeType = 5
	// vm-docker, language-golang
	RuntimeType_DOCKER_GO RuntimeType = 6
	// vm-docker, language-java
	RuntimeType_DOCKER_JAVA RuntimeType = 7
)

var RuntimeType_name = map[int32]string{
	0: "INVALID",
	1: "NATIVE",
	2: "WASMER",
	3: "WXVM",
	4: "GASM",
	5: "EVM",
	6: "DOCKER_GO",
	7: "DOCKER_JAVA",
}

var RuntimeType_value = map[string]int32{
	"INVALID":     0,
	"NATIVE":      1,
	"WASMER":      2,
	"WXVM":        3,
	"GASM":        4,
	"EVM":         5,
	"DOCKER_GO":   6,
	"DOCKER_JAVA": 7,
}

func (x RuntimeType) String() string {
	return proto.EnumName(RuntimeType_name, int32(x))
}

func (RuntimeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}

type ConfigFunction int32

const (
	// get chain configuration
	ConfigFunction_GET_CHAIN_CONFIG ConfigFunction = 0
	// get the latest configuration block
	// the incoming blockheight must exist in the database
	// 如果传入的blockHeight是配置块，直接返回当前的配置信息
	ConfigFunction_GET_CHAIN_CONFIG_AT ConfigFunction = 1
	// update core
	ConfigFunction_CORE_UPDATE ConfigFunction = 2
	// update block
	ConfigFunction_BLOCK_UPDATE ConfigFunction = 3
	// add trusted certficate (org_id and root)
	ConfigFunction_TRUST_ROOT_ADD ConfigFunction = 4
	// [self] modify an individual's own trusted root certificate [org_id must exist in the original trust_roots,
	// and the new root certificate must be different from other certificates]
	ConfigFunction_TRUST_ROOT_UPDATE ConfigFunction = 5
	// delete trusted root certificate [org_ ID should be in trust_ The nodes in nodes need to be deleted]
	ConfigFunction_TRUST_ROOT_DELETE ConfigFunction = 6
	// organization add node address
	// org_id must already exist in nodes，you can add addresses in batches
	// the parameter is addresses. Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	// Deprecated , replace by NODE_ID_ADD
	ConfigFunction_NODE_ADDR_ADD ConfigFunction = 7
	// [self]the organization updates an address
	//[org_id and address must already exist in nodes, new_address is the new address. ip+port and peerId cannot be duplicated]
	// Deprecated , replace by NODE_ID_UPDATE
	ConfigFunction_NODE_ADDR_UPDATE ConfigFunction = 8
	// organization delete node address [org_id and address must already exist in nodes]
	// Deprecated , replace by NODE_ID_DELETE
	ConfigFunction_NODE_ADDR_DELETE ConfigFunction = 9
	// organization add node address in batches [org_id在nodes不存在，批量添加地址，参数为node_ids，单地址用逗号","隔开。nodeId不能重复]
	ConfigFunction_NODE_ORG_ADD ConfigFunction = 10
	// organization update
	// org_id must already exist in nodes，the parameter is addresses，Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	ConfigFunction_NODE_ORG_UPDATE ConfigFunction = 11
	// organization delete, org_id must already exist in nodes
	ConfigFunction_NODE_ORG_DELETE ConfigFunction = 12
	// add consensus parameters, key is not exit in ext_config
	ConfigFunction_CONSENSUS_EXT_ADD ConfigFunction = 13
	// update onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_UPDATE ConfigFunction = 14
	// delete onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_DELETE ConfigFunction = 15
	// add permission
	ConfigFunction_PERMISSION_ADD ConfigFunction = 16
	// update permission
	ConfigFunction_PERMISSION_UPDATE ConfigFunction = 17
	// delete permission
	ConfigFunction_PERMISSION_DELETE ConfigFunction = 18
	// organization add node_id
	// org_id must already exist in nodes，you can add node_id in batches
	// the parameter is node_ids. Single node_ids are separated by ","
	// node_id cannot be repeated
	ConfigFunction_NODE_ID_ADD ConfigFunction = 19
	// [self]the organization updates a node_ids
	//[org_id and node_ids must already exist in nodes, new_node_id is the new node_id. node_id cannot be duplicated]
	ConfigFunction_NODE_ID_UPDATE ConfigFunction = 20
	// organization delete node_id [org_id and node_id must already exist in nodes]
	ConfigFunction_NODE_ID_DELETE ConfigFunction = 21
	// add trusted certficate (org_id and root)
	ConfigFunction_TRUST_MEMBER_ADD ConfigFunction = 22
	// [self] modify an individual's own trusted root certificate [org_id must exist in the original trust_roots,
	// and the new root certificate must be different from other certificates]
	ConfigFunction_TRUST_MEMBER_UPDATE ConfigFunction = 23
	// delete trusted root certificate [org_ ID should be in trust_ The nodes in nodes need to be deleted]
	ConfigFunction_TRUST_MEMBER_DELETE ConfigFunction = 24
)

var ConfigFunction_name = map[int32]string{
	0:  "GET_CHAIN_CONFIG",
	1:  "GET_CHAIN_CONFIG_AT",
	2:  "CORE_UPDATE",
	3:  "BLOCK_UPDATE",
	4:  "TRUST_ROOT_ADD",
	5:  "TRUST_ROOT_UPDATE",
	6:  "TRUST_ROOT_DELETE",
	7:  "NODE_ADDR_ADD",
	8:  "NODE_ADDR_UPDATE",
	9:  "NODE_ADDR_DELETE",
	10: "NODE_ORG_ADD",
	11: "NODE_ORG_UPDATE",
	12: "NODE_ORG_DELETE",
	13: "CONSENSUS_EXT_ADD",
	14: "CONSENSUS_EXT_UPDATE",
	15: "CONSENSUS_EXT_DELETE",
	16: "PERMISSION_ADD",
	17: "PERMISSION_UPDATE",
	18: "PERMISSION_DELETE",
	19: "NODE_ID_ADD",
	20: "NODE_ID_UPDATE",
	21: "NODE_ID_DELETE",
	22: "TRUST_MEMBER_ADD",
	23: "TRUST_MEMBER_UPDATE",
	24: "TRUST_MEMBER_DELETE",
}

var ConfigFunction_value = map[string]int32{
	"GET_CHAIN_CONFIG":     0,
	"GET_CHAIN_CONFIG_AT":  1,
	"CORE_UPDATE":          2,
	"BLOCK_UPDATE":         3,
	"TRUST_ROOT_ADD":       4,
	"TRUST_ROOT_UPDATE":    5,
	"TRUST_ROOT_DELETE":    6,
	"NODE_ADDR_ADD":        7,
	"NODE_ADDR_UPDATE":     8,
	"NODE_ADDR_DELETE":     9,
	"NODE_ORG_ADD":         10,
	"NODE_ORG_UPDATE":      11,
	"NODE_ORG_DELETE":      12,
	"CONSENSUS_EXT_ADD":    13,
	"CONSENSUS_EXT_UPDATE": 14,
	"CONSENSUS_EXT_DELETE": 15,
	"PERMISSION_ADD":       16,
	"PERMISSION_UPDATE":    17,
	"PERMISSION_DELETE":    18,
	"NODE_ID_ADD":          19,
	"NODE_ID_UPDATE":       20,
	"NODE_ID_DELETE":       21,
	"TRUST_MEMBER_ADD":     22,
	"TRUST_MEMBER_UPDATE":  23,
	"TRUST_MEMBER_DELETE":  24,
}

func (x ConfigFunction) String() string {
	return proto.EnumName(ConfigFunction_name, int32(x))
}

func (ConfigFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{3}
}

// Methods of certificate management
type CertManageFunction int32

const (
	// add certficate
	CertManageFunction_CERT_ADD CertManageFunction = 0
	// delete certficate
	CertManageFunction_CERTS_DELETE CertManageFunction = 1
	// query certficate
	CertManageFunction_CERTS_QUERY CertManageFunction = 2
	// freeze certificate
	CertManageFunction_CERTS_FREEZE CertManageFunction = 3
	// unfreezing certificate
	CertManageFunction_CERTS_UNFREEZE CertManageFunction = 4
	// Revocation of certificate
	CertManageFunction_CERTS_REVOKE CertManageFunction = 5
)

var CertManageFunction_name = map[int32]string{
	0: "CERT_ADD",
	1: "CERTS_DELETE",
	2: "CERTS_QUERY",
	3: "CERTS_FREEZE",
	4: "CERTS_UNFREEZE",
	5: "CERTS_REVOKE",
}

var CertManageFunction_value = map[string]int32{
	"CERT_ADD":       0,
	"CERTS_DELETE":   1,
	"CERTS_QUERY":    2,
	"CERTS_FREEZE":   3,
	"CERTS_UNFREEZE": 4,
	"CERTS_REVOKE":   5,
}

func (x CertManageFunction) String() string {
	return proto.EnumName(CertManageFunction_name, int32(x))
}

func (CertManageFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{4}
}

// methods of managing multi signature
type MultiSignFunction int32

const (
	// multi signature request
	MultiSignFunction_REQ MultiSignFunction = 0
	// multi signature voting
	MultiSignFunction_VOTE MultiSignFunction = 1
	// multi signature query
	MultiSignFunction_QUERY MultiSignFunction = 2
)

var MultiSignFunction_name = map[int32]string{
	0: "REQ",
	1: "VOTE",
	2: "QUERY",
}

var MultiSignFunction_value = map[string]int32{
	"REQ":   0,
	"VOTE":  1,
	"QUERY": 2,
}

func (x MultiSignFunction) String() string {
	return proto.EnumName(MultiSignFunction_name, int32(x))
}

func (MultiSignFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{5}
}

// methods of user management contract
type ManageUserContractFunction int32

const (
	// init contract
	ManageUserContractFunction_INIT_CONTRACT ManageUserContractFunction = 0
	// upgrade contract
	ManageUserContractFunction_UPGRADE_CONTRACT ManageUserContractFunction = 1
	// freeze  contract
	ManageUserContractFunction_FREEZE_CONTRACT ManageUserContractFunction = 2
	// unfreezing contract
	ManageUserContractFunction_UNFREEZE_CONTRACT ManageUserContractFunction = 3
	// Revocation of contract
	ManageUserContractFunction_REVOKE_CONTRACT ManageUserContractFunction = 4
)

var ManageUserContractFunction_name = map[int32]string{
	0: "INIT_CONTRACT",
	1: "UPGRADE_CONTRACT",
	2: "FREEZE_CONTRACT",
	3: "UNFREEZE_CONTRACT",
	4: "REVOKE_CONTRACT",
}

var ManageUserContractFunction_value = map[string]int32{
	"INIT_CONTRACT":     0,
	"UPGRADE_CONTRACT":  1,
	"FREEZE_CONTRACT":   2,
	"UNFREEZE_CONTRACT": 3,
	"REVOKE_CONTRACT":   4,
}

func (x ManageUserContractFunction) String() string {
	return proto.EnumName(ManageUserContractFunction_name, int32(x))
}

func (ManageUserContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{6}
}

// methods of private compute contract
type PrivateComputeContractFunction int32

const (
	// get contract code
	PrivateComputeContractFunction_GET_CONTRACT PrivateComputeContractFunction = 0
	// get private data
	PrivateComputeContractFunction_GET_DATA PrivateComputeContractFunction = 1
	// save cert of tee
	PrivateComputeContractFunction_SAVE_CERT PrivateComputeContractFunction = 2
	// save private data dir
	PrivateComputeContractFunction_SAVE_DIR PrivateComputeContractFunction = 3
	// save data of private computation result
	PrivateComputeContractFunction_SAVE_DATA PrivateComputeContractFunction = 4
	//save contract code
	PrivateComputeContractFunction_SAVE_CONTRACT PrivateComputeContractFunction = 5
	//save enclave quote
	PrivateComputeContractFunction_SAVE_QUOTE PrivateComputeContractFunction = 6
	//get enclave quote
	PrivateComputeContractFunction_GET_QUOTE PrivateComputeContractFunction = 7
	//get cert of tee
	PrivateComputeContractFunction_GET_CERT PrivateComputeContractFunction = 8
	//get private data dir
	PrivateComputeContractFunction_GET_DIR PrivateComputeContractFunction = 9
)

var PrivateComputeContractFunction_name = map[int32]string{
	0: "GET_CONTRACT",
	1: "GET_DATA",
	2: "SAVE_CERT",
	3: "SAVE_DIR",
	4: "SAVE_DATA",
	5: "SAVE_CONTRACT",
	6: "SAVE_QUOTE",
	7: "GET_QUOTE",
	8: "GET_CERT",
	9: "GET_DIR",
}

var PrivateComputeContractFunction_value = map[string]int32{
	"GET_CONTRACT":  0,
	"GET_DATA":      1,
	"SAVE_CERT":     2,
	"SAVE_DIR":      3,
	"SAVE_DATA":     4,
	"SAVE_CONTRACT": 5,
	"SAVE_QUOTE":    6,
	"GET_QUOTE":     7,
	"GET_CERT":      8,
	"GET_DIR":       9,
}

func (x PrivateComputeContractFunction) String() string {
	return proto.EnumName(PrivateComputeContractFunction_name, int32(x))
}

func (PrivateComputeContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{7}
}

// the unique identifier of a smart contract
type ContractId struct {
	// smart contract name, set by contract creator, can have multiple versions
	ContractName string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// smart contract version, set by contract creator, name + version should be unique
	ContractVersion string `protobuf:"bytes,2,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	// smart contract runtime type, set by contract creator
	RuntimeType RuntimeType `protobuf:"varint,3,opt,name=runtime_type,json=runtimeType,proto3,enum=common.RuntimeType" json:"runtime_type,omitempty"`
}

func (m *ContractId) Reset()         { *m = ContractId{} }
func (m *ContractId) String() string { return proto.CompactTextString(m) }
func (*ContractId) ProtoMessage()    {}
func (*ContractId) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}
func (m *ContractId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractId.Merge(m, src)
}
func (m *ContractId) XXX_Size() int {
	return m.Size()
}
func (m *ContractId) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractId.DiscardUnknown(m)
}

var xxx_messageInfo_ContractId proto.InternalMessageInfo

func (m *ContractId) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *ContractId) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *ContractId) GetRuntimeType() RuntimeType {
	if m != nil {
		return m.RuntimeType
	}
	return RuntimeType_INVALID
}

type ContractInfo struct {
	ContractTransaction []*ContractTransaction `protobuf:"bytes,1,rep,name=contract_transaction,json=contractTransaction,proto3" json:"contract_transaction,omitempty"`
}

func (m *ContractInfo) Reset()         { *m = ContractInfo{} }
func (m *ContractInfo) String() string { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()    {}
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}
func (m *ContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInfo.Merge(m, src)
}
func (m *ContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInfo proto.InternalMessageInfo

func (m *ContractInfo) GetContractTransaction() []*ContractTransaction {
	if m != nil {
		return m.ContractTransaction
	}
	return nil
}

type ContractTransaction struct {
	ContractId *ContractId `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	TxId       string      `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (m *ContractTransaction) Reset()         { *m = ContractTransaction{} }
func (m *ContractTransaction) String() string { return proto.CompactTextString(m) }
func (*ContractTransaction) ProtoMessage()    {}
func (*ContractTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}
func (m *ContractTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractTransaction.Merge(m, src)
}
func (m *ContractTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ContractTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ContractTransaction proto.InternalMessageInfo

func (m *ContractTransaction) GetContractId() *ContractId {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *ContractTransaction) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func init() {
	proto.RegisterEnum("common.ContractName", ContractName_name, ContractName_value)
	proto.RegisterEnum("common.QueryFunction", QueryFunction_name, QueryFunction_value)
	proto.RegisterEnum("common.RuntimeType", RuntimeType_name, RuntimeType_value)
	proto.RegisterEnum("common.ConfigFunction", ConfigFunction_name, ConfigFunction_value)
	proto.RegisterEnum("common.CertManageFunction", CertManageFunction_name, CertManageFunction_value)
	proto.RegisterEnum("common.MultiSignFunction", MultiSignFunction_name, MultiSignFunction_value)
	proto.RegisterEnum("common.ManageUserContractFunction", ManageUserContractFunction_name, ManageUserContractFunction_value)
	proto.RegisterEnum("common.PrivateComputeContractFunction", PrivateComputeContractFunction_name, PrivateComputeContractFunction_value)
	proto.RegisterType((*ContractId)(nil), "common.ContractId")
	proto.RegisterType((*ContractInfo)(nil), "common.ContractInfo")
	proto.RegisterType((*ContractTransaction)(nil), "common.ContractTransaction")
}

func init() { proto.RegisterFile("common/contract.proto", fileDescriptor_a1095c55e7168440) }

var fileDescriptor_a1095c55e7168440 = []byte{
	// 1091 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0x4f, 0x4f, 0xe3, 0x46,
	0x14, 0x8f, 0xf3, 0x97, 0xbc, 0x24, 0x30, 0x4c, 0x60, 0x37, 0xdd, 0xad, 0xb2, 0x74, 0x57, 0x95,
	0x68, 0xa4, 0x82, 0xca, 0x4a, 0xbd, 0x1b, 0x7b, 0x08, 0x2e, 0xb1, 0x1d, 0xc6, 0x13, 0x03, 0x7b,
	0xa8, 0x15, 0x82, 0x37, 0x8d, 0xda, 0xd8, 0x91, 0x31, 0xab, 0xe5, 0xd0, 0x6b, 0xcf, 0x3d, 0xf4,
	0x6b, 0xf4, 0x03, 0xf4, 0x1b, 0xec, 0x71, 0x8f, 0x3d, 0x56, 0x70, 0xed, 0x87, 0xa8, 0x66, 0x3c,
	0xb6, 0x43, 0x40, 0x3d, 0xe1, 0xf9, 0xbd, 0xdf, 0xfb, 0xbd, 0x37, 0xbf, 0x99, 0x79, 0x04, 0xb6,
	0x27, 0xe1, 0x7c, 0x1e, 0x06, 0xfb, 0x93, 0x30, 0x88, 0xa3, 0xf1, 0x24, 0xde, 0x5b, 0x44, 0x61,
	0x1c, 0xe2, 0x6a, 0x02, 0xbf, 0xfe, 0x43, 0x01, 0xd0, 0x64, 0xc8, 0xb8, 0xc2, 0x6f, 0xa0, 0x95,
	0x12, 0xbd, 0x60, 0x3c, 0xf7, 0x3b, 0xca, 0x8e, 0xb2, 0x5b, 0xa7, 0xcd, 0x14, 0xb4, 0xc6, 0x73,
	0x1f, 0x7f, 0x03, 0x28, 0x23, 0x7d, 0xf0, 0xa3, 0xeb, 0x59, 0x18, 0x74, 0x8a, 0x82, 0xb7, 0x91,
	0xe2, 0x6e, 0x02, 0xe3, 0xef, 0xa1, 0x19, 0xdd, 0x04, 0xf1, 0x6c, 0xee, 0x7b, 0xf1, 0xed, 0xc2,
	0xef, 0x94, 0x76, 0x94, 0xdd, 0xf5, 0x83, 0xf6, 0x5e, 0x52, 0x7d, 0x8f, 0x26, 0x31, 0x76, 0xbb,
	0xf0, 0x69, 0x23, 0xca, 0x17, 0xaf, 0x7f, 0x84, 0x66, 0xd6, 0x55, 0xf0, 0x3e, 0xc4, 0x16, 0x6c,
	0x65, 0x25, 0xe3, 0x68, 0x1c, 0x5c, 0x8f, 0x27, 0x31, 0x2f, 0xab, 0xec, 0x94, 0x76, 0x1b, 0x07,
	0x2f, 0x53, 0xbd, 0x34, 0x87, 0xe5, 0x14, 0xda, 0x9e, 0x3c, 0x06, 0x5f, 0x7b, 0xd0, 0x7e, 0x82,
	0x8b, 0xdf, 0x42, 0x23, 0x2b, 0x33, 0xbb, 0x12, 0x9b, 0x6f, 0x1c, 0xe0, 0x55, 0x75, 0xe3, 0x8a,
	0xc2, 0x24, 0xf7, 0xac, 0x0d, 0x95, 0xf8, 0x23, 0xa7, 0x27, 0x1e, 0x94, 0xe3, 0x8f, 0xc6, 0x55,
	0xef, 0x5f, 0x25, 0xdf, 0x81, 0x30, 0x6d, 0x07, 0xbe, 0x74, 0x2e, 0x1c, 0x46, 0x4c, 0x4f, 0xb3,
	0x2d, 0x46, 0x55, 0x8d, 0x79, 0xda, 0xb1, 0x6a, 0x58, 0x7c, 0x79, 0x64, 0xf4, 0x51, 0x01, 0x7f,
	0x01, 0xdb, 0xab, 0x8c, 0xd3, 0x11, 0xa1, 0x17, 0x48, 0xc1, 0xaf, 0xe0, 0xe5, 0xa3, 0x64, 0x42,
	0x99, 0x67, 0xaa, 0x96, 0xda, 0x27, 0xa8, 0x88, 0xbb, 0xf0, 0x62, 0x95, 0xd0, 0xb7, 0x5d, 0x42,
	0x2d, 0xd5, 0xd2, 0x08, 0x2a, 0x3d, 0x15, 0x37, 0x47, 0x03, 0x66, 0x78, 0x8e, 0xd1, 0xb7, 0x50,
	0xf9, 0xa9, 0xda, 0x0e, 0x53, 0x19, 0x41, 0x15, 0xfc, 0x06, 0x5e, 0xad, 0x86, 0x86, 0xd4, 0x70,
	0x55, 0x46, 0x3c, 0xcd, 0x36, 0x87, 0x23, 0x46, 0x50, 0xb5, 0xf7, 0xa9, 0x08, 0xad, 0xd3, 0x1b,
	0x3f, 0xba, 0x3d, 0xba, 0x09, 0x12, 0x2b, 0x9f, 0x01, 0xee, 0x13, 0xe6, 0x1d, 0x0e, 0x6c, 0xed,
	0xc4, 0x3b, 0xbc, 0xf0, 0xd8, 0xb9, 0x67, 0xe8, 0xa8, 0x80, 0xb7, 0x61, 0x93, 0xe3, 0x99, 0x96,
	0x61, 0x1d, 0xd9, 0x48, 0xc1, 0x6d, 0xd8, 0xe0, 0x30, 0x3b, 0xcf, 0xb9, 0x45, 0xfc, 0x1c, 0xda,
	0x0f, 0x34, 0x8e, 0x89, 0xd1, 0x3f, 0x66, 0xa8, 0x84, 0x31, 0xac, 0x0b, 0x11, 0x61, 0xa0, 0x50,
	0x10, 0x5b, 0xe0, 0xd8, 0x40, 0x75, 0x98, 0xf4, 0x34, 0x49, 0x44, 0x95, 0xb4, 0x66, 0xae, 0xa3,
	0x3a, 0xc7, 0xa8, 0x9a, 0xca, 0x5b, 0xb6, 0x4e, 0xa4, 0xd4, 0xc0, 0x70, 0x18, 0xaa, 0xe1, 0x97,
	0xf0, 0x9c, 0x07, 0x72, 0x07, 0xb3, 0x76, 0xd1, 0x1a, 0xfe, 0x1a, 0xbe, 0xca, 0xc5, 0xce, 0x0c,
	0x76, 0xec, 0xb1, 0x73, 0x7a, 0xe6, 0x10, 0xe6, 0x2c, 0xb5, 0x58, 0xe7, 0xb6, 0xfd, 0x1f, 0x8d,
	0x77, 0x00, 0xe9, 0x3e, 0x44, 0xcf, 0x49, 0xb3, 0x8d, 0x5e, 0x08, 0x8d, 0xa5, 0x67, 0x81, 0x1b,
	0x50, 0x33, 0x2c, 0x57, 0x1d, 0x08, 0xf3, 0x00, 0xaa, 0x96, 0xca, 0x0c, 0x97, 0x20, 0x85, 0x7f,
	0x9f, 0xa9, 0x8e, 0x49, 0x28, 0x2a, 0xe2, 0x35, 0x28, 0x9f, 0x9d, 0xbb, 0x26, 0x2a, 0xf1, 0xaf,
	0xbe, 0xea, 0x98, 0xa8, 0x8c, 0x6b, 0x50, 0x22, 0xae, 0x89, 0x2a, 0xb8, 0x05, 0x75, 0xdd, 0xd6,
	0x4e, 0x08, 0xf5, 0xfa, 0x36, 0xaa, 0xe2, 0x0d, 0x68, 0xc8, 0xe5, 0x0f, 0xaa, 0xab, 0xa2, 0x5a,
	0xef, 0xcf, 0x32, 0xac, 0x6b, 0x61, 0xf0, 0x7e, 0x36, 0xcd, 0x0e, 0x6f, 0x0b, 0x50, 0xee, 0x6f,
	0x76, 0x41, 0xa5, 0x5f, 0xcb, 0xa8, 0xa7, 0x32, 0xa4, 0x70, 0x49, 0xcd, 0xa6, 0xc4, 0x1b, 0x0d,
	0x75, 0x7e, 0x67, 0x8a, 0x18, 0x41, 0x33, 0xd9, 0xb8, 0x44, 0xc4, 0x89, 0x31, 0x3a, 0x72, 0x98,
	0x47, 0x6d, 0x9b, 0x79, 0xaa, 0xae, 0xa3, 0x32, 0x3f, 0x96, 0x25, 0x4c, 0x52, 0x2b, 0x2b, 0xb0,
	0x4e, 0x06, 0x84, 0x5f, 0x31, 0xbc, 0x09, 0x2d, 0x71, 0x52, 0xaa, 0xae, 0x53, 0x21, 0x50, 0xe3,
	0x6d, 0xe6, 0x90, 0xcc, 0x5f, 0x7b, 0x88, 0xca, 0xf4, 0x3a, 0x6f, 0x49, 0xa0, 0x36, 0xed, 0x8b,
	0x6c, 0xe0, 0x57, 0x2e, 0x43, 0x64, 0x72, 0xe3, 0x01, 0x28, 0x73, 0x9b, 0xbc, 0x23, 0xcd, 0xb6,
	0x1c, 0x62, 0x39, 0x23, 0xc7, 0x23, 0xe7, 0x49, 0xff, 0x2d, 0xdc, 0x81, 0xad, 0x87, 0xb0, 0x54,
	0x59, 0x7f, 0x1c, 0x91, 0x52, 0x1b, 0xdc, 0x87, 0x21, 0xa1, 0xa6, 0xe1, 0x38, 0x86, 0x6d, 0x09,
	0x1d, 0xc4, 0xe5, 0x97, 0x30, 0x29, 0xb2, 0xb9, 0x02, 0x4b, 0x05, 0xcc, 0xcd, 0x16, 0x1d, 0x1a,
	0xba, 0x48, 0x6f, 0x73, 0xc9, 0x14, 0x90, 0xb9, 0x5b, 0xcb, 0x98, 0x4c, 0xdc, 0xe6, 0xbe, 0x24,
	0xbe, 0x9a, 0xc4, 0x3c, 0x24, 0x89, 0x87, 0xcf, 0xf8, 0xa1, 0x3e, 0x40, 0xa5, 0xc4, 0xf3, 0x47,
	0x01, 0xa9, 0xd3, 0xe9, 0xfd, 0x0a, 0x58, 0xf3, 0xa3, 0xd8, 0x1c, 0x07, 0xe3, 0xa9, 0x9f, 0x5d,
	0x99, 0x26, 0xac, 0x89, 0x91, 0xc4, 0x55, 0x0b, 0xdc, 0x6d, 0xbe, 0x72, 0xd2, 0xac, 0xe4, 0x8e,
	0x08, 0x24, 0x99, 0x69, 0xc5, 0x9c, 0x72, 0x44, 0x09, 0x79, 0x27, 0xef, 0x48, 0x82, 0x8c, 0x2c,
	0x89, 0x95, 0x73, 0x16, 0x25, 0xae, 0x7d, 0x42, 0x50, 0xa5, 0xf7, 0x1d, 0x6c, 0x9a, 0x37, 0xbf,
	0xc4, 0x33, 0x67, 0x36, 0x0d, 0xb2, 0xea, 0x35, 0x28, 0x51, 0x72, 0x8a, 0x0a, 0xfc, 0xfe, 0xbb,
	0xb6, 0x28, 0x58, 0x87, 0x8a, 0x2c, 0xd5, 0xfb, 0x4d, 0x81, 0x17, 0x49, 0xbb, 0xa3, 0x6b, 0x3f,
	0x4a, 0xc7, 0x72, 0x96, 0xbc, 0x09, 0x2d, 0xc3, 0x32, 0xf2, 0x99, 0x84, 0x0a, 0xdc, 0xab, 0xd1,
	0xb0, 0x4f, 0x55, 0x7d, 0xe9, 0xe9, 0x8b, 0x21, 0x95, 0x34, 0x96, 0x83, 0x45, 0x7e, 0x4c, 0x69,
	0xbf, 0x39, 0x5c, 0xe2, 0xdc, 0xa4, 0xe5, 0x1c, 0x2c, 0xf7, 0xfe, 0x52, 0xa0, 0x3b, 0x8c, 0x66,
	0x1f, 0xc6, 0xb1, 0xaf, 0x85, 0xf3, 0xc5, 0x0d, 0xff, 0xb3, 0xd2, 0x0c, 0x82, 0xe6, 0xf2, 0x7c,
	0x44, 0x05, 0xee, 0x2c, 0x47, 0x74, 0x95, 0xa9, 0x48, 0xe1, 0xaf, 0xd9, 0x51, 0x5d, 0x22, 0xe6,
	0x3f, 0x2a, 0xf2, 0xa0, 0x58, 0xea, 0x06, 0x45, 0xa5, 0x2c, 0x28, 0xb8, 0x65, 0xbe, 0xb1, 0x84,
	0x9b, 0x8a, 0x55, 0xf0, 0x3a, 0x80, 0x80, 0x4e, 0x47, 0xb6, 0x78, 0x55, 0x2d, 0xa8, 0x73, 0xf1,
	0x64, 0x59, 0x4b, 0x6b, 0x09, 0xf1, 0x35, 0x3e, 0x7b, 0x44, 0x65, 0x83, 0xa2, 0xfa, 0xe1, 0xe5,
	0xa7, 0xbb, 0xae, 0xf2, 0xf9, 0xae, 0xab, 0xfc, 0x73, 0xd7, 0x55, 0x7e, 0xbf, 0xef, 0x16, 0x3e,
	0xdf, 0x77, 0x0b, 0x7f, 0xdf, 0x77, 0x0b, 0xd0, 0x09, 0xa3, 0xe9, 0xde, 0xe4, 0xa7, 0xf1, 0x2c,
	0x98, 0x8f, 0x7f, 0xf6, 0xa3, 0xbd, 0xc5, 0xa5, 0xfc, 0x8f, 0xf9, 0x6e, 0x19, 0x0d, 0xa3, 0xe9,
	0x7e, 0xbe, 0xfc, 0x76, 0x1a, 0xee, 0x2f, 0x2e, 0xf7, 0xc5, 0x8f, 0x91, 0x69, 0xb8, 0x9f, 0xf0,
	0x2f, 0xab, 0x62, 0xfd, 0xf6, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x66, 0x99, 0xe0, 0xf2, 0xb5,
	0x08, 0x00, 0x00,
}

func (m *ContractId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuntimeType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.RuntimeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for iNdEx := len(m.ContractTransaction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContractTransaction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContractTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContractId != nil {
		{
			size, err := m.ContractId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintContract(dAtA []byte, offset int, v uint64) int {
	offset -= sovContract(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContractId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RuntimeType != 0 {
		n += 1 + sovContract(uint64(m.RuntimeType))
	}
	return n
}

func (m *ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for _, e := range m.ContractTransaction {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *ContractTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractId != nil {
		l = m.ContractId.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func sovContract(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozContract(x uint64) (n int) {
	return sovContract(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContractId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeType", wireType)
			}
			m.RuntimeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeType |= RuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractTransaction = append(m.ContractTransaction, &ContractTransaction{})
			if err := m.ContractTransaction[len(m.ContractTransaction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractId == nil {
				m.ContractId = &ContractId{}
			}
			if err := m.ContractId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContract(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContract
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthContract
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupContract
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthContract
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthContract        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContract          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupContract = fmt.Errorf("proto: unexpected end of group")
)
