// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/contract.proto

package common

import (
	accesscontrol "chainmaker.org/chainmaker-sdk-go/pb/protogo/accesscontrol"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContractName int32

const (
	// system chain configuration contract
	// used to add, delete and change the chain configuration
	ContractName_SYSTEM_CONTRACT_CHAIN_CONFIG ContractName = 0
	// system chain query contract
	// used to query the configuration on the chain
	ContractName_SYSTEM_CONTRACT_QUERY ContractName = 1
	// system certificate storage contract
	// used to manage certificates
	ContractName_SYSTEM_CONTRACT_CERT_MANAGE ContractName = 2
	// governance contract
	ContractName_SYSTEM_CONTRACT_GOVERNANCE ContractName = 3
	// multi signature contract on chain
	ContractName_SYSTEM_CONTRACT_MULTI_SIGN ContractName = 4
	// contract state
	ContractName_SYSTEM_CONTRACT_STATE ContractName = 5
	// private compute contract
	ContractName_SYSTEM_CONTRACT_PRIVATE_COMPUTE ContractName = 6
)

var ContractName_name = map[int32]string{
	0: "SYSTEM_CONTRACT_CHAIN_CONFIG",
	1: "SYSTEM_CONTRACT_QUERY",
	2: "SYSTEM_CONTRACT_CERT_MANAGE",
	3: "SYSTEM_CONTRACT_GOVERNANCE",
	4: "SYSTEM_CONTRACT_MULTI_SIGN",
	5: "SYSTEM_CONTRACT_STATE",
	6: "SYSTEM_CONTRACT_PRIVATE_COMPUTE",
}

var ContractName_value = map[string]int32{
	"SYSTEM_CONTRACT_CHAIN_CONFIG":    0,
	"SYSTEM_CONTRACT_QUERY":           1,
	"SYSTEM_CONTRACT_CERT_MANAGE":     2,
	"SYSTEM_CONTRACT_GOVERNANCE":      3,
	"SYSTEM_CONTRACT_MULTI_SIGN":      4,
	"SYSTEM_CONTRACT_STATE":           5,
	"SYSTEM_CONTRACT_PRIVATE_COMPUTE": 6,
}

func (x ContractName) String() string {
	return proto.EnumName(ContractName_name, int32(x))
}

func (ContractName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}

type QueryFunction int32

const (
	// get block by transactionId
	QueryFunction_GET_BLOCK_BY_TX_ID QueryFunction = 0
	// get contract information
	QueryFunction_GET_CONTRACT_INFO QueryFunction = 1
	// get transaction by transactionId
	QueryFunction_GET_TX_BY_TX_ID QueryFunction = 2
	// get block by block height
	QueryFunction_GET_BLOCK_BY_HEIGHT QueryFunction = 3
	// get chain information
	QueryFunction_GET_CHAIN_INFO QueryFunction = 4
	// get the last configuration block
	QueryFunction_GET_LAST_CONFIG_BLOCK QueryFunction = 5
	// get block by block hash
	QueryFunction_GET_BLOCK_BY_HASH QueryFunction = 6
	// get the list of node
	QueryFunction_GET_NODE_CHAIN_LIST QueryFunction = 7
	// get governance information
	QueryFunction_GET_GOVERNANCE_CONTRACT QueryFunction = 8
	// get read/write set information by eight
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT QueryFunction = 9
	// get read/write set information by hash
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HASH QueryFunction = 10
	// get the last block
	QueryFunction_GET_LAST_BLOCK QueryFunction = 11
	// get full block by height
	QueryFunction_GET_FULL_BLOCK_BY_HEIGHT QueryFunction = 12
	// get block height by tx id
	QueryFunction_GET_BLOCK_HEIGHT_BY_TX_ID QueryFunction = 13
	// get block height by hash
	QueryFunction_GET_BLOCK_HEIGHT_BY_HASH QueryFunction = 14
	//get block header by height
	QueryFunction_GET_BLOCK_HEADER_BY_HEIGHT QueryFunction = 15
	// get archived block height
	QueryFunction_GET_ARCHIVED_BLOCK_HEIGHT QueryFunction = 16
	//get contract bytecode
	QueryFunction_GET_CONTRACT_BYTECODE QueryFunction = 17
	//get all contract info list
	QueryFunction_GET_ALL_CONTRACTS QueryFunction = 18
)

var QueryFunction_name = map[int32]string{
	0:  "GET_BLOCK_BY_TX_ID",
	1:  "GET_CONTRACT_INFO",
	2:  "GET_TX_BY_TX_ID",
	3:  "GET_BLOCK_BY_HEIGHT",
	4:  "GET_CHAIN_INFO",
	5:  "GET_LAST_CONFIG_BLOCK",
	6:  "GET_BLOCK_BY_HASH",
	7:  "GET_NODE_CHAIN_LIST",
	8:  "GET_GOVERNANCE_CONTRACT",
	9:  "GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT",
	10: "GET_BLOCK_WITH_TXRWSETS_BY_HASH",
	11: "GET_LAST_BLOCK",
	12: "GET_FULL_BLOCK_BY_HEIGHT",
	13: "GET_BLOCK_HEIGHT_BY_TX_ID",
	14: "GET_BLOCK_HEIGHT_BY_HASH",
	15: "GET_BLOCK_HEADER_BY_HEIGHT",
	16: "GET_ARCHIVED_BLOCK_HEIGHT",
	17: "GET_CONTRACT_BYTECODE",
	18: "GET_ALL_CONTRACTS",
}

var QueryFunction_value = map[string]int32{
	"GET_BLOCK_BY_TX_ID":                0,
	"GET_CONTRACT_INFO":                 1,
	"GET_TX_BY_TX_ID":                   2,
	"GET_BLOCK_BY_HEIGHT":               3,
	"GET_CHAIN_INFO":                    4,
	"GET_LAST_CONFIG_BLOCK":             5,
	"GET_BLOCK_BY_HASH":                 6,
	"GET_NODE_CHAIN_LIST":               7,
	"GET_GOVERNANCE_CONTRACT":           8,
	"GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT": 9,
	"GET_BLOCK_WITH_TXRWSETS_BY_HASH":   10,
	"GET_LAST_BLOCK":                    11,
	"GET_FULL_BLOCK_BY_HEIGHT":          12,
	"GET_BLOCK_HEIGHT_BY_TX_ID":         13,
	"GET_BLOCK_HEIGHT_BY_HASH":          14,
	"GET_BLOCK_HEADER_BY_HEIGHT":        15,
	"GET_ARCHIVED_BLOCK_HEIGHT":         16,
	"GET_CONTRACT_BYTECODE":             17,
	"GET_ALL_CONTRACTS":                 18,
}

func (x QueryFunction) String() string {
	return proto.EnumName(QueryFunction_name, int32(x))
}

func (QueryFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}

// smart contract runtime, contains vm type and language type
type RuntimeType int32

const (
	RuntimeType_INVALID RuntimeType = 0
	// native implement in chainmaker-go
	RuntimeType_NATIVE RuntimeType = 1
	// vm-wasmer, language-c++
	RuntimeType_WASMER RuntimeType = 2
	// vm-wxvm, language-cpp
	RuntimeType_WXVM RuntimeType = 3
	// wasm interpreter in go
	RuntimeType_GASM RuntimeType = 4
	// vm-evm
	RuntimeType_EVM RuntimeType = 5
	// vm-docker, language-golang
	RuntimeType_DOCKER_GO RuntimeType = 6
	// vm-docker, language-java
	RuntimeType_DOCKER_JAVA RuntimeType = 7
)

var RuntimeType_name = map[int32]string{
	0: "INVALID",
	1: "NATIVE",
	2: "WASMER",
	3: "WXVM",
	4: "GASM",
	5: "EVM",
	6: "DOCKER_GO",
	7: "DOCKER_JAVA",
}

var RuntimeType_value = map[string]int32{
	"INVALID":     0,
	"NATIVE":      1,
	"WASMER":      2,
	"WXVM":        3,
	"GASM":        4,
	"EVM":         5,
	"DOCKER_GO":   6,
	"DOCKER_JAVA": 7,
}

func (x RuntimeType) String() string {
	return proto.EnumName(RuntimeType_name, int32(x))
}

func (RuntimeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}

type ConfigFunction int32

const (
	// get chain configuration
	ConfigFunction_GET_CHAIN_CONFIG ConfigFunction = 0
	// get the latest configuration block
	// the incoming blockheight must exist in the database
	// 如果传入的blockHeight是配置块，直接返回当前的配置信息
	ConfigFunction_GET_CHAIN_CONFIG_AT ConfigFunction = 1
	// update core
	ConfigFunction_CORE_UPDATE ConfigFunction = 2
	// update block
	ConfigFunction_BLOCK_UPDATE ConfigFunction = 3
	// add trusted certficate (org_id and root)
	ConfigFunction_TRUST_ROOT_ADD ConfigFunction = 4
	// [self] modify an individual's own trusted root certificate [org_id must exist in the original trust_roots,
	// and the new root certificate must be different from other certificates]
	ConfigFunction_TRUST_ROOT_UPDATE ConfigFunction = 5
	// delete trusted root certificate [org_ ID should be in trust_ The nodes in nodes need to be deleted]
	ConfigFunction_TRUST_ROOT_DELETE ConfigFunction = 6
	// organization add node address
	// org_id must already exist in nodes，you can add addresses in batches
	// the parameter is addresses. Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	// Deprecated , replace by NODE_ID_ADD
	ConfigFunction_NODE_ADDR_ADD ConfigFunction = 7
	// [self]the organization updates an address
	//[org_id and address must already exist in nodes, new_address is the new address. ip+port and peerId cannot be duplicated]
	// Deprecated , replace by NODE_ID_UPDATE
	ConfigFunction_NODE_ADDR_UPDATE ConfigFunction = 8
	// organization delete node address [org_id and address must already exist in nodes]
	// Deprecated , replace by NODE_ID_DELETE
	ConfigFunction_NODE_ADDR_DELETE ConfigFunction = 9
	// organization add node address in batches [org_id在nodes不存在，批量添加地址，参数为node_ids，单地址用逗号","隔开。nodeId不能重复]
	ConfigFunction_NODE_ORG_ADD ConfigFunction = 10
	// organization update
	// org_id must already exist in nodes，the parameter is addresses，Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	ConfigFunction_NODE_ORG_UPDATE ConfigFunction = 11
	// organization delete, org_id must already exist in nodes
	ConfigFunction_NODE_ORG_DELETE ConfigFunction = 12
	// add consensus parameters, key is not exit in ext_config
	ConfigFunction_CONSENSUS_EXT_ADD ConfigFunction = 13
	// update onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_UPDATE ConfigFunction = 14
	// delete onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_DELETE ConfigFunction = 15
	// add permission
	ConfigFunction_PERMISSION_ADD ConfigFunction = 16
	// update permission
	ConfigFunction_PERMISSION_UPDATE ConfigFunction = 17
	// delete permission
	ConfigFunction_PERMISSION_DELETE ConfigFunction = 18
	// organization add node_id
	// org_id must already exist in nodes，you can add node_id in batches
	// the parameter is node_ids. Single node_ids are separated by ","
	// node_id cannot be repeated
	ConfigFunction_NODE_ID_ADD ConfigFunction = 19
	// [self]the organization updates a node_ids
	//[org_id and node_ids must already exist in nodes, new_node_id is the new node_id. node_id cannot be duplicated]
	ConfigFunction_NODE_ID_UPDATE ConfigFunction = 20
	// organization delete node_id [org_id and node_id must already exist in nodes]
	ConfigFunction_NODE_ID_DELETE ConfigFunction = 21
)

var ConfigFunction_name = map[int32]string{
	0:  "GET_CHAIN_CONFIG",
	1:  "GET_CHAIN_CONFIG_AT",
	2:  "CORE_UPDATE",
	3:  "BLOCK_UPDATE",
	4:  "TRUST_ROOT_ADD",
	5:  "TRUST_ROOT_UPDATE",
	6:  "TRUST_ROOT_DELETE",
	7:  "NODE_ADDR_ADD",
	8:  "NODE_ADDR_UPDATE",
	9:  "NODE_ADDR_DELETE",
	10: "NODE_ORG_ADD",
	11: "NODE_ORG_UPDATE",
	12: "NODE_ORG_DELETE",
	13: "CONSENSUS_EXT_ADD",
	14: "CONSENSUS_EXT_UPDATE",
	15: "CONSENSUS_EXT_DELETE",
	16: "PERMISSION_ADD",
	17: "PERMISSION_UPDATE",
	18: "PERMISSION_DELETE",
	19: "NODE_ID_ADD",
	20: "NODE_ID_UPDATE",
	21: "NODE_ID_DELETE",
}

var ConfigFunction_value = map[string]int32{
	"GET_CHAIN_CONFIG":     0,
	"GET_CHAIN_CONFIG_AT":  1,
	"CORE_UPDATE":          2,
	"BLOCK_UPDATE":         3,
	"TRUST_ROOT_ADD":       4,
	"TRUST_ROOT_UPDATE":    5,
	"TRUST_ROOT_DELETE":    6,
	"NODE_ADDR_ADD":        7,
	"NODE_ADDR_UPDATE":     8,
	"NODE_ADDR_DELETE":     9,
	"NODE_ORG_ADD":         10,
	"NODE_ORG_UPDATE":      11,
	"NODE_ORG_DELETE":      12,
	"CONSENSUS_EXT_ADD":    13,
	"CONSENSUS_EXT_UPDATE": 14,
	"CONSENSUS_EXT_DELETE": 15,
	"PERMISSION_ADD":       16,
	"PERMISSION_UPDATE":    17,
	"PERMISSION_DELETE":    18,
	"NODE_ID_ADD":          19,
	"NODE_ID_UPDATE":       20,
	"NODE_ID_DELETE":       21,
}

func (x ConfigFunction) String() string {
	return proto.EnumName(ConfigFunction_name, int32(x))
}

func (ConfigFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{3}
}

// Methods of certificate management
type CertManageFunction int32

const (
	// add certficate
	CertManageFunction_CERT_ADD CertManageFunction = 0
	// delete certficate
	CertManageFunction_CERTS_DELETE CertManageFunction = 1
	// query certficate
	CertManageFunction_CERTS_QUERY CertManageFunction = 2
	// freeze certificate
	CertManageFunction_CERTS_FREEZE CertManageFunction = 3
	// unfreezing certificate
	CertManageFunction_CERTS_UNFREEZE CertManageFunction = 4
	// Revocation of certificate
	CertManageFunction_CERTS_REVOKE CertManageFunction = 5
)

var CertManageFunction_name = map[int32]string{
	0: "CERT_ADD",
	1: "CERTS_DELETE",
	2: "CERTS_QUERY",
	3: "CERTS_FREEZE",
	4: "CERTS_UNFREEZE",
	5: "CERTS_REVOKE",
}

var CertManageFunction_value = map[string]int32{
	"CERT_ADD":       0,
	"CERTS_DELETE":   1,
	"CERTS_QUERY":    2,
	"CERTS_FREEZE":   3,
	"CERTS_UNFREEZE": 4,
	"CERTS_REVOKE":   5,
}

func (x CertManageFunction) String() string {
	return proto.EnumName(CertManageFunction_name, int32(x))
}

func (CertManageFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{4}
}

// methods of managing multi signature
type MultiSignFunction int32

const (
	// multi signature request
	MultiSignFunction_REQ MultiSignFunction = 0
	// multi signature voting
	MultiSignFunction_VOTE MultiSignFunction = 1
	// multi signature query
	MultiSignFunction_QUERY MultiSignFunction = 2
)

var MultiSignFunction_name = map[int32]string{
	0: "REQ",
	1: "VOTE",
	2: "QUERY",
}

var MultiSignFunction_value = map[string]int32{
	"REQ":   0,
	"VOTE":  1,
	"QUERY": 2,
}

func (x MultiSignFunction) String() string {
	return proto.EnumName(MultiSignFunction_name, int32(x))
}

func (MultiSignFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{5}
}

// methods of user management contract
type ManageUserContractFunction int32

const (
	// init contract
	ManageUserContractFunction_INIT_CONTRACT ManageUserContractFunction = 0
	// upgrade contract
	ManageUserContractFunction_UPGRADE_CONTRACT ManageUserContractFunction = 1
	// freeze  contract
	ManageUserContractFunction_FREEZE_CONTRACT ManageUserContractFunction = 2
	// unfreezing contract
	ManageUserContractFunction_UNFREEZE_CONTRACT ManageUserContractFunction = 3
	// Revocation of contract
	ManageUserContractFunction_REVOKE_CONTRACT ManageUserContractFunction = 4
)

var ManageUserContractFunction_name = map[int32]string{
	0: "INIT_CONTRACT",
	1: "UPGRADE_CONTRACT",
	2: "FREEZE_CONTRACT",
	3: "UNFREEZE_CONTRACT",
	4: "REVOKE_CONTRACT",
}

var ManageUserContractFunction_value = map[string]int32{
	"INIT_CONTRACT":     0,
	"UPGRADE_CONTRACT":  1,
	"FREEZE_CONTRACT":   2,
	"UNFREEZE_CONTRACT": 3,
	"REVOKE_CONTRACT":   4,
}

func (x ManageUserContractFunction) String() string {
	return proto.EnumName(ManageUserContractFunction_name, int32(x))
}

func (ManageUserContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{6}
}

// methods of private compute contract
type PrivateComputeContractFunction int32

const (
	// get contract code
	PrivateComputeContractFunction_GET_CONTRACT PrivateComputeContractFunction = 0
	// get private data
	PrivateComputeContractFunction_GET_DATA PrivateComputeContractFunction = 1
	// save cert of tee
	PrivateComputeContractFunction_SAVE_CA_CERT PrivateComputeContractFunction = 2
	// save private data dir
	PrivateComputeContractFunction_SAVE_DIR PrivateComputeContractFunction = 3
	// save data of private computation result
	PrivateComputeContractFunction_SAVE_DATA PrivateComputeContractFunction = 4
	//save enclave report
	PrivateComputeContractFunction_SAVE_ENCLAVE_REPORT PrivateComputeContractFunction = 5
	//get enclave proof
	PrivateComputeContractFunction_GET_ENCLAVE_PROOF PrivateComputeContractFunction = 6
	//get cert of tee
	PrivateComputeContractFunction_GET_CA_CERT PrivateComputeContractFunction = 7
	//get private data dir
	PrivateComputeContractFunction_GET_DIR PrivateComputeContractFunction = 8
	//checkCallerCertAuth
	PrivateComputeContractFunction_CHECK_CALLER_CERT_AUTH           PrivateComputeContractFunction = 9
	PrivateComputeContractFunction_GET_ENCLAVE_ENCRYPT_PUB_KEY      PrivateComputeContractFunction = 10
	PrivateComputeContractFunction_GET_ENCLAVE_VERIFICATION_PUB_KEY PrivateComputeContractFunction = 11
	PrivateComputeContractFunction_GET_ENCLAVE_REPORT               PrivateComputeContractFunction = 12
	PrivateComputeContractFunction_GET_ENCLAVE_CHALLENGE            PrivateComputeContractFunction = 13
	PrivateComputeContractFunction_GET_ENCLAVE_SIGNATURE            PrivateComputeContractFunction = 14
	PrivateComputeContractFunction_SAVE_REMOTE_ATTESTATION          PrivateComputeContractFunction = 15
)

var PrivateComputeContractFunction_name = map[int32]string{
	0:  "GET_CONTRACT",
	1:  "GET_DATA",
	2:  "SAVE_CA_CERT",
	3:  "SAVE_DIR",
	4:  "SAVE_DATA",
	5:  "SAVE_ENCLAVE_REPORT",
	6:  "GET_ENCLAVE_PROOF",
	7:  "GET_CA_CERT",
	8:  "GET_DIR",
	9:  "CHECK_CALLER_CERT_AUTH",
	10: "GET_ENCLAVE_ENCRYPT_PUB_KEY",
	11: "GET_ENCLAVE_VERIFICATION_PUB_KEY",
	12: "GET_ENCLAVE_REPORT",
	13: "GET_ENCLAVE_CHALLENGE",
	14: "GET_ENCLAVE_SIGNATURE",
	15: "SAVE_REMOTE_ATTESTATION",
}

var PrivateComputeContractFunction_value = map[string]int32{
	"GET_CONTRACT":                     0,
	"GET_DATA":                         1,
	"SAVE_CA_CERT":                     2,
	"SAVE_DIR":                         3,
	"SAVE_DATA":                        4,
	"SAVE_ENCLAVE_REPORT":              5,
	"GET_ENCLAVE_PROOF":                6,
	"GET_CA_CERT":                      7,
	"GET_DIR":                          8,
	"CHECK_CALLER_CERT_AUTH":           9,
	"GET_ENCLAVE_ENCRYPT_PUB_KEY":      10,
	"GET_ENCLAVE_VERIFICATION_PUB_KEY": 11,
	"GET_ENCLAVE_REPORT":               12,
	"GET_ENCLAVE_CHALLENGE":            13,
	"GET_ENCLAVE_SIGNATURE":            14,
	"SAVE_REMOTE_ATTESTATION":          15,
}

func (x PrivateComputeContractFunction) String() string {
	return proto.EnumName(PrivateComputeContractFunction_name, int32(x))
}

func (PrivateComputeContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{7}
}

//ContractStatus 合约状态
type ContractStatus int32

const (
	//未知
	ContractStatus_UNKNOWN ContractStatus = 0
	//普通正常状态
	ContractStatus_NORMAL ContractStatus = 1
	//冻结
	ContractStatus_FROZEN ContractStatus = 2
	//被撤销
	ContractStatus_REVOKED ContractStatus = 3
)

var ContractStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORMAL",
	2: "FROZEN",
	3: "REVOKED",
}

var ContractStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"NORMAL":  1,
	"FROZEN":  2,
	"REVOKED": 3,
}

func (x ContractStatus) String() string {
	return proto.EnumName(ContractStatus_name, int32(x))
}

func (ContractStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{8}
}

type ContractType int32

const (
	//normal,support parallel
	ContractType_PARALLEL ContractType = 0
	//don't support parallel, for example: SQL contract
	ContractType_SERIAL ContractType = 1
	//like Fabric contract, run contract need add endorsement, for example: TEE contract
	ContractType_ENDORSE ContractType = 2
	//only pack 1 tx in block
	ContractType_SINGLE ContractType = 4
)

var ContractType_name = map[int32]string{
	0: "PARALLEL",
	1: "SERIAL",
	2: "ENDORSE",
	4: "SINGLE",
}

var ContractType_value = map[string]int32{
	"PARALLEL": 0,
	"SERIAL":   1,
	"ENDORSE":  2,
	"SINGLE":   4,
}

func (x ContractType) String() string {
	return proto.EnumName(ContractType_name, int32(x))
}

func (ContractType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{9}
}

// the unique identifier of a smart contract
type ContractId struct {
	// smart contract name, set by contract creator, can have multiple versions
	ContractName string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// smart contract version, set by contract creator, name + version should be unique
	ContractVersion string `protobuf:"bytes,2,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	// smart contract runtime type, set by contract creator
	RuntimeType RuntimeType `protobuf:"varint,3,opt,name=runtime_type,json=runtimeType,proto3,enum=common.RuntimeType" json:"runtime_type,omitempty"`
}

func (m *ContractId) Reset()         { *m = ContractId{} }
func (m *ContractId) String() string { return proto.CompactTextString(m) }
func (*ContractId) ProtoMessage()    {}
func (*ContractId) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}
func (m *ContractId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractId.Merge(m, src)
}
func (m *ContractId) XXX_Size() int {
	return m.Size()
}
func (m *ContractId) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractId.DiscardUnknown(m)
}

var xxx_messageInfo_ContractId proto.InternalMessageInfo

func (m *ContractId) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *ContractId) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *ContractId) GetRuntimeType() RuntimeType {
	if m != nil {
		return m.RuntimeType
	}
	return RuntimeType_INVALID
}

type ContractInfo struct {
	ContractTransaction []*ContractTransaction `protobuf:"bytes,1,rep,name=contract_transaction,json=contractTransaction,proto3" json:"contract_transaction,omitempty"`
}

func (m *ContractInfo) Reset()         { *m = ContractInfo{} }
func (m *ContractInfo) String() string { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()    {}
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}
func (m *ContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInfo.Merge(m, src)
}
func (m *ContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInfo proto.InternalMessageInfo

func (m *ContractInfo) GetContractTransaction() []*ContractTransaction {
	if m != nil {
		return m.ContractTransaction
	}
	return nil
}

type ContractTransaction struct {
	ContractId *ContractId `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	TxId       string      `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (m *ContractTransaction) Reset()         { *m = ContractTransaction{} }
func (m *ContractTransaction) String() string { return proto.CompactTextString(m) }
func (*ContractTransaction) ProtoMessage()    {}
func (*ContractTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}
func (m *ContractTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractTransaction.Merge(m, src)
}
func (m *ContractTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ContractTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ContractTransaction proto.InternalMessageInfo

func (m *ContractTransaction) GetContractId() *ContractId {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *ContractTransaction) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type RemoteAttestationRequest struct {
	SignPair []*SignInfo               `protobuf:"bytes,1,rep,name=sign_pair,json=signPair,proto3" json:"sign_pair,omitempty"`
	Payload  *RemoteAttestationPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *RemoteAttestationRequest) Reset()         { *m = RemoteAttestationRequest{} }
func (m *RemoteAttestationRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteAttestationRequest) ProtoMessage()    {}
func (*RemoteAttestationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{3}
}
func (m *RemoteAttestationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteAttestationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteAttestationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteAttestationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteAttestationRequest.Merge(m, src)
}
func (m *RemoteAttestationRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoteAttestationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteAttestationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteAttestationRequest proto.InternalMessageInfo

func (m *RemoteAttestationRequest) GetSignPair() []*SignInfo {
	if m != nil {
		return m.SignPair
	}
	return nil
}

func (m *RemoteAttestationRequest) GetPayload() *RemoteAttestationPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RemoteAttestationPayload struct {
	Challenge string   `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	OrgId     []string `protobuf:"bytes,2,rep,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
}

func (m *RemoteAttestationPayload) Reset()         { *m = RemoteAttestationPayload{} }
func (m *RemoteAttestationPayload) String() string { return proto.CompactTextString(m) }
func (*RemoteAttestationPayload) ProtoMessage()    {}
func (*RemoteAttestationPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{4}
}
func (m *RemoteAttestationPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteAttestationPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteAttestationPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteAttestationPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteAttestationPayload.Merge(m, src)
}
func (m *RemoteAttestationPayload) XXX_Size() int {
	return m.Size()
}
func (m *RemoteAttestationPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteAttestationPayload.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteAttestationPayload proto.InternalMessageInfo

func (m *RemoteAttestationPayload) GetChallenge() string {
	if m != nil {
		return m.Challenge
	}
	return ""
}

func (m *RemoteAttestationPayload) GetOrgId() []string {
	if m != nil {
		return m.OrgId
	}
	return nil
}

type PrivateDeployRequest struct {
	SignPair []*SignInfo    `protobuf:"bytes,1,rep,name=sign_pair,json=signPair,proto3" json:"sign_pair,omitempty"`
	Payload  *DeployPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrivateDeployRequest) Reset()         { *m = PrivateDeployRequest{} }
func (m *PrivateDeployRequest) String() string { return proto.CompactTextString(m) }
func (*PrivateDeployRequest) ProtoMessage()    {}
func (*PrivateDeployRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{5}
}
func (m *PrivateDeployRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivateDeployRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivateDeployRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivateDeployRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateDeployRequest.Merge(m, src)
}
func (m *PrivateDeployRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrivateDeployRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateDeployRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateDeployRequest proto.InternalMessageInfo

func (m *PrivateDeployRequest) GetSignPair() []*SignInfo {
	if m != nil {
		return m.SignPair
	}
	return nil
}

func (m *PrivateDeployRequest) GetPayload() *DeployPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type DeployPayload struct {
	CodeBytes string `protobuf:"bytes,1,opt,name=code_bytes,json=codeBytes,proto3" json:"code_bytes,omitempty"`
	// deploy args which is packed by abi
	PrivateRlpData  string   `protobuf:"bytes,2,opt,name=private_rlp_data,json=privateRlpData,proto3" json:"private_rlp_data,omitempty"`
	Passwd          string   `protobuf:"bytes,3,opt,name=passwd,proto3" json:"passwd,omitempty"`
	SigAlgo         string   `protobuf:"bytes,4,opt,name=sig_algo,json=sigAlgo,proto3" json:"sig_algo,omitempty"`
	ContractName    string   `protobuf:"bytes,5,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractVersion string   `protobuf:"bytes,6,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	CodeHash        string   `protobuf:"bytes,7,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	OrgId           []string `protobuf:"bytes,8,rep,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
}

func (m *DeployPayload) Reset()         { *m = DeployPayload{} }
func (m *DeployPayload) String() string { return proto.CompactTextString(m) }
func (*DeployPayload) ProtoMessage()    {}
func (*DeployPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{6}
}
func (m *DeployPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeployPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeployPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployPayload.Merge(m, src)
}
func (m *DeployPayload) XXX_Size() int {
	return m.Size()
}
func (m *DeployPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployPayload.DiscardUnknown(m)
}

var xxx_messageInfo_DeployPayload proto.InternalMessageInfo

func (m *DeployPayload) GetCodeBytes() string {
	if m != nil {
		return m.CodeBytes
	}
	return ""
}

func (m *DeployPayload) GetPrivateRlpData() string {
	if m != nil {
		return m.PrivateRlpData
	}
	return ""
}

func (m *DeployPayload) GetPasswd() string {
	if m != nil {
		return m.Passwd
	}
	return ""
}

func (m *DeployPayload) GetSigAlgo() string {
	if m != nil {
		return m.SigAlgo
	}
	return ""
}

func (m *DeployPayload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *DeployPayload) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *DeployPayload) GetCodeHash() string {
	if m != nil {
		return m.CodeHash
	}
	return ""
}

func (m *DeployPayload) GetOrgId() []string {
	if m != nil {
		return m.OrgId
	}
	return nil
}

type PrivateComputeRequest struct {
	SignPair []*SignInfo `protobuf:"bytes,1,rep,name=sign_pair,json=signPair,proto3" json:"sign_pair,omitempty"`
	Payload  *Payload    `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PrivateComputeRequest) Reset()         { *m = PrivateComputeRequest{} }
func (m *PrivateComputeRequest) String() string { return proto.CompactTextString(m) }
func (*PrivateComputeRequest) ProtoMessage()    {}
func (*PrivateComputeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{7}
}
func (m *PrivateComputeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivateComputeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivateComputeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivateComputeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateComputeRequest.Merge(m, src)
}
func (m *PrivateComputeRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrivateComputeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateComputeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateComputeRequest proto.InternalMessageInfo

func (m *PrivateComputeRequest) GetSignPair() []*SignInfo {
	if m != nil {
		return m.SignPair
	}
	return nil
}

func (m *PrivateComputeRequest) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Payload struct {
	PrivateRlpData string   `protobuf:"bytes,1,opt,name=private_rlp_data,json=privateRlpData,proto3" json:"private_rlp_data,omitempty"`
	Passwd         string   `protobuf:"bytes,2,opt,name=passwd,proto3" json:"passwd,omitempty"`
	SigAlgo        string   `protobuf:"bytes,3,opt,name=sig_algo,json=sigAlgo,proto3" json:"sig_algo,omitempty"`
	ContractName   string   `protobuf:"bytes,4,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	CodeHash       string   `protobuf:"bytes,5,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	OrgId          []string `protobuf:"bytes,6,rep,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{8}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetPrivateRlpData() string {
	if m != nil {
		return m.PrivateRlpData
	}
	return ""
}

func (m *Payload) GetPasswd() string {
	if m != nil {
		return m.Passwd
	}
	return ""
}

func (m *Payload) GetSigAlgo() string {
	if m != nil {
		return m.SigAlgo
	}
	return ""
}

func (m *Payload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *Payload) GetCodeHash() string {
	if m != nil {
		return m.CodeHash
	}
	return ""
}

func (m *Payload) GetOrgId() []string {
	if m != nil {
		return m.OrgId
	}
	return nil
}

type SignInfo struct {
	ClientSign string `protobuf:"bytes,1,opt,name=client_sign,json=clientSign,proto3" json:"client_sign,omitempty"`
	Cert       string `protobuf:"bytes,2,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *SignInfo) Reset()         { *m = SignInfo{} }
func (m *SignInfo) String() string { return proto.CompactTextString(m) }
func (*SignInfo) ProtoMessage()    {}
func (*SignInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{9}
}
func (m *SignInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInfo.Merge(m, src)
}
func (m *SignInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignInfo proto.InternalMessageInfo

func (m *SignInfo) GetClientSign() string {
	if m != nil {
		return m.ClientSign
	}
	return ""
}

func (m *SignInfo) GetCert() string {
	if m != nil {
		return m.Cert
	}
	return ""
}

type Contract struct {
	// smart contract name, set by contract creator, can have multiple versions
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// smart contract version, set by contract creator, name + version should be unique
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// smart contract runtime type, set by contract creator
	RuntimeType RuntimeType `protobuf:"varint,3,opt,name=runtime_type,json=runtimeType,proto3,enum=common.RuntimeType" json:"runtime_type,omitempty"`
	//contract status
	Status ContractStatus `protobuf:"varint,4,opt,name=status,proto3,enum=common.ContractStatus" json:"status,omitempty"`
	// contract run parallel or need endorsement
	Type ContractType `protobuf:"varint,5,opt,name=type,proto3,enum=common.ContractType" json:"type,omitempty"`
	//if need endorsement,specify policy
	EndorsePolicy *accesscontrol.Policy `protobuf:"bytes,6,opt,name=endorse_policy,json=endorsePolicy,proto3" json:"endorse_policy,omitempty"`
	//contract upgrade policy
	UpdatePolicy *accesscontrol.Policy `protobuf:"bytes,7,opt,name=update_policy,json=updatePolicy,proto3" json:"update_policy,omitempty"`
	//contract initial block timestamp
	CreateTime int64 `protobuf:"varint,8,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	//contract creator identity
	Creator *accesscontrol.SerializedMember `protobuf:"bytes,9,opt,name=creator,proto3" json:"creator,omitempty"`
	//contract identity
	Address *accesscontrol.SerializedMember `protobuf:"bytes,10,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{10}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contract) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Contract) GetRuntimeType() RuntimeType {
	if m != nil {
		return m.RuntimeType
	}
	return RuntimeType_INVALID
}

func (m *Contract) GetStatus() ContractStatus {
	if m != nil {
		return m.Status
	}
	return ContractStatus_UNKNOWN
}

func (m *Contract) GetType() ContractType {
	if m != nil {
		return m.Type
	}
	return ContractType_PARALLEL
}

func (m *Contract) GetEndorsePolicy() *accesscontrol.Policy {
	if m != nil {
		return m.EndorsePolicy
	}
	return nil
}

func (m *Contract) GetUpdatePolicy() *accesscontrol.Policy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

func (m *Contract) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Contract) GetCreator() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *Contract) GetAddress() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Address
	}
	return nil
}

type ContractList struct {
	Contracts []*Contract `protobuf:"bytes,1,rep,name=contracts,proto3" json:"contracts,omitempty"`
}

func (m *ContractList) Reset()         { *m = ContractList{} }
func (m *ContractList) String() string { return proto.CompactTextString(m) }
func (*ContractList) ProtoMessage()    {}
func (*ContractList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{11}
}
func (m *ContractList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractList.Merge(m, src)
}
func (m *ContractList) XXX_Size() int {
	return m.Size()
}
func (m *ContractList) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractList.DiscardUnknown(m)
}

var xxx_messageInfo_ContractList proto.InternalMessageInfo

func (m *ContractList) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func init() {
	proto.RegisterEnum("common.ContractName", ContractName_name, ContractName_value)
	proto.RegisterEnum("common.QueryFunction", QueryFunction_name, QueryFunction_value)
	proto.RegisterEnum("common.RuntimeType", RuntimeType_name, RuntimeType_value)
	proto.RegisterEnum("common.ConfigFunction", ConfigFunction_name, ConfigFunction_value)
	proto.RegisterEnum("common.CertManageFunction", CertManageFunction_name, CertManageFunction_value)
	proto.RegisterEnum("common.MultiSignFunction", MultiSignFunction_name, MultiSignFunction_value)
	proto.RegisterEnum("common.ManageUserContractFunction", ManageUserContractFunction_name, ManageUserContractFunction_value)
	proto.RegisterEnum("common.PrivateComputeContractFunction", PrivateComputeContractFunction_name, PrivateComputeContractFunction_value)
	proto.RegisterEnum("common.ContractStatus", ContractStatus_name, ContractStatus_value)
	proto.RegisterEnum("common.ContractType", ContractType_name, ContractType_value)
	proto.RegisterType((*ContractId)(nil), "common.ContractId")
	proto.RegisterType((*ContractInfo)(nil), "common.ContractInfo")
	proto.RegisterType((*ContractTransaction)(nil), "common.ContractTransaction")
	proto.RegisterType((*RemoteAttestationRequest)(nil), "common.RemoteAttestationRequest")
	proto.RegisterType((*RemoteAttestationPayload)(nil), "common.RemoteAttestationPayload")
	proto.RegisterType((*PrivateDeployRequest)(nil), "common.PrivateDeployRequest")
	proto.RegisterType((*DeployPayload)(nil), "common.DeployPayload")
	proto.RegisterType((*PrivateComputeRequest)(nil), "common.PrivateComputeRequest")
	proto.RegisterType((*Payload)(nil), "common.Payload")
	proto.RegisterType((*SignInfo)(nil), "common.SignInfo")
	proto.RegisterType((*Contract)(nil), "common.Contract")
	proto.RegisterType((*ContractList)(nil), "common.ContractList")
}

func init() { proto.RegisterFile("common/contract.proto", fileDescriptor_a1095c55e7168440) }

var fileDescriptor_a1095c55e7168440 = []byte{
	// 1863 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4d, 0x6f, 0xe3, 0xc8,
	0x11, 0x35, 0xf5, 0xad, 0x92, 0x64, 0xb7, 0xdb, 0xf6, 0x8c, 0x66, 0x3c, 0xeb, 0x71, 0xbc, 0x09,
	0xe0, 0x15, 0x30, 0x36, 0xe2, 0x05, 0x02, 0x64, 0x11, 0x24, 0xa0, 0xc9, 0xb6, 0xc4, 0x58, 0x22,
	0x35, 0x4d, 0x4a, 0xb6, 0xe7, 0x10, 0x82, 0x96, 0x38, 0xb2, 0xb0, 0x92, 0xa8, 0x25, 0xe9, 0xc9,
	0x3a, 0x40, 0x8e, 0xc9, 0x25, 0x87, 0xe4, 0xb0, 0xff, 0x27, 0xd7, 0x1c, 0xf7, 0x18, 0x20, 0x97,
	0x60, 0x06, 0xb9, 0xe5, 0x47, 0x2c, 0xba, 0x9b, 0x14, 0x29, 0xc9, 0xfb, 0x81, 0x39, 0x59, 0xfd,
	0xea, 0xd5, 0xab, 0xea, 0xea, 0xae, 0x6a, 0xc2, 0xb0, 0x37, 0xf0, 0xa6, 0x53, 0x6f, 0x76, 0x3a,
	0xf0, 0x66, 0xa1, 0xef, 0x0c, 0xc2, 0x93, 0xb9, 0xef, 0x85, 0x1e, 0x2e, 0x08, 0xf8, 0xf9, 0x73,
	0x67, 0x30, 0x70, 0x83, 0x80, 0x5b, 0xbd, 0xc9, 0xe9, 0xd4, 0x9d, 0xde, 0xba, 0xbe, 0xe0, 0xac,
	0xda, 0xe6, 0xde, 0x64, 0x3c, 0x78, 0x10, 0xb6, 0xa3, 0x6f, 0x24, 0x00, 0x25, 0x92, 0xd4, 0x86,
	0xf8, 0x53, 0xa8, 0xc5, 0x01, 0xec, 0x99, 0x33, 0x75, 0xeb, 0xd2, 0xa1, 0x74, 0x5c, 0xa6, 0xd5,
	0x18, 0xd4, 0x9d, 0xa9, 0x8b, 0x3f, 0x03, 0xb4, 0x20, 0xbd, 0x73, 0xfd, 0x60, 0xec, 0xcd, 0xea,
	0x19, 0xce, 0xdb, 0x8a, 0xf1, 0xbe, 0x80, 0xf1, 0xaf, 0xa0, 0xea, 0xdf, 0xcf, 0xc2, 0xf1, 0xd4,
	0xb5, 0xc3, 0x87, 0xb9, 0x5b, 0xcf, 0x1e, 0x4a, 0xc7, 0x9b, 0x67, 0x3b, 0x27, 0x22, 0xeb, 0x13,
	0x2a, 0x6c, 0xd6, 0xc3, 0xdc, 0xa5, 0x15, 0x3f, 0x59, 0x1c, 0xfd, 0x01, 0xaa, 0x8b, 0xac, 0x66,
	0x6f, 0x3d, 0xac, 0xc3, 0xee, 0x22, 0x64, 0xe8, 0x3b, 0xb3, 0xc0, 0x19, 0x84, 0x2c, 0xac, 0x74,
	0x98, 0x3d, 0xae, 0x9c, 0xed, 0xc7, 0x7a, 0xb1, 0x8f, 0x95, 0x50, 0xe8, 0xce, 0x60, 0x1d, 0x3c,
	0xb2, 0x61, 0xe7, 0x11, 0x2e, 0xfe, 0x1c, 0x2a, 0x8b, 0x30, 0xe3, 0x21, 0xdf, 0x7c, 0xe5, 0x0c,
	0xaf, 0xaa, 0x6b, 0x43, 0x0a, 0x83, 0xa4, 0x66, 0x3b, 0x90, 0x0f, 0xbf, 0x66, 0x74, 0x51, 0x83,
	0x5c, 0xf8, 0xb5, 0x36, 0x3c, 0xfa, 0x8b, 0x04, 0x75, 0xea, 0x4e, 0xbd, 0xd0, 0x95, 0xc3, 0xd0,
	0x0d, 0x42, 0x87, 0xe7, 0xe2, 0x7e, 0x75, 0xef, 0x06, 0x21, 0x7e, 0x05, 0xe5, 0x60, 0x3c, 0x9a,
	0xd9, 0x73, 0x67, 0xec, 0x47, 0x5b, 0x40, 0x71, 0x10, 0x73, 0x3c, 0x9a, 0xb1, 0x2d, 0xd3, 0x12,
	0xa3, 0x74, 0x9d, 0xb1, 0x8f, 0xbf, 0x80, 0xe2, 0xdc, 0x79, 0x98, 0x78, 0x8e, 0x08, 0x51, 0x39,
	0x3b, 0x5c, 0xd4, 0x6f, 0x35, 0x42, 0x57, 0xf0, 0x68, 0xec, 0x70, 0x64, 0x3c, 0x92, 0x46, 0x44,
	0xc2, 0x2f, 0xa0, 0x3c, 0xb8, 0x73, 0x26, 0x13, 0x77, 0x36, 0x8a, 0x0f, 0x3a, 0x01, 0xf0, 0x1e,
	0x14, 0x3c, 0x7f, 0x24, 0xf6, 0x95, 0x3d, 0x2e, 0xd3, 0xbc, 0xe7, 0x8f, 0xb4, 0xe1, 0xd1, 0x3b,
	0xd8, 0xed, 0xfa, 0xe3, 0x77, 0x4e, 0xe8, 0xaa, 0xee, 0x7c, 0xe2, 0x3d, 0x7c, 0xe4, 0x9e, 0x4e,
	0x57, 0xf7, 0xb4, 0x17, 0x93, 0x85, 0xec, 0xda, 0x46, 0xfe, 0x9e, 0x81, 0xda, 0x92, 0x09, 0x7f,
	0x02, 0x30, 0xf0, 0x86, 0xae, 0x7d, 0xfb, 0x10, 0xba, 0xc1, 0x22, 0x7f, 0x6f, 0xe8, 0x9e, 0x33,
	0x00, 0x1f, 0x03, 0x9a, 0x8b, 0x44, 0x6d, 0x7f, 0x32, 0xb7, 0x87, 0x4e, 0xe8, 0x44, 0x27, 0xb4,
	0x19, 0xe1, 0x74, 0x32, 0x57, 0x9d, 0xd0, 0xc1, 0x4f, 0xa0, 0x30, 0x77, 0x82, 0xe0, 0x8f, 0x43,
	0x7e, 0x3d, 0xcb, 0x34, 0x5a, 0xe1, 0x67, 0xc0, 0xf2, 0xb5, 0x9d, 0xc9, 0xc8, 0xab, 0xe7, 0xb8,
	0xa5, 0x18, 0x8c, 0x47, 0xf2, 0x64, 0xe4, 0xad, 0xf7, 0x49, 0xfe, 0x27, 0xf6, 0x49, 0xe1, 0xf1,
	0x3e, 0xd9, 0x07, 0x9e, 0xb9, 0x7d, 0xe7, 0x04, 0x77, 0xf5, 0x22, 0xe7, 0x94, 0x18, 0xd0, 0x72,
	0x82, 0xbb, 0xd4, 0x49, 0x94, 0xd2, 0x27, 0xf1, 0x15, 0xec, 0x45, 0x27, 0xa1, 0x78, 0xd3, 0xf9,
	0x7d, 0xe8, 0x7e, 0xe4, 0x51, 0x7c, 0xb6, 0x7a, 0x14, 0x5b, 0x31, 0x79, 0xed, 0x10, 0xfe, 0x29,
	0x41, 0x31, 0x2e, 0xff, 0x63, 0xf5, 0x95, 0x7e, 0xa4, 0xbe, 0x99, 0xef, 0xad, 0x6f, 0xf6, 0x47,
	0xea, 0x9b, 0x7b, 0xa4, 0xbe, 0x4b, 0x45, 0xcb, 0x7f, 0x6f, 0xd1, 0x0a, 0xe9, 0xa2, 0xfd, 0x0e,
	0x4a, 0x71, 0x09, 0xf0, 0x4b, 0xa8, 0x0c, 0x26, 0x63, 0x77, 0x16, 0xda, 0xac, 0x16, 0x51, 0xf2,
	0x20, 0x20, 0x46, 0xc2, 0x18, 0x72, 0x03, 0xd7, 0x0f, 0xe3, 0xc6, 0x66, 0xbf, 0x8f, 0xfe, 0x93,
	0x85, 0x52, 0x3c, 0x08, 0x18, 0x21, 0x35, 0x25, 0xf9, 0x6f, 0x5c, 0x87, 0xe2, 0xf2, 0x50, 0x8c,
	0x97, 0x1f, 0x3b, 0x0c, 0xf1, 0x09, 0x14, 0x58, 0xe7, 0xde, 0x07, 0xbc, 0x0a, 0x9b, 0x67, 0x4f,
	0x56, 0x07, 0x92, 0xc9, 0xad, 0x34, 0x62, 0xe1, 0x63, 0xc8, 0x71, 0xfd, 0x3c, 0x67, 0xef, 0xae,
	0x0d, 0x47, 0x16, 0x80, 0x33, 0xf0, 0x6f, 0x60, 0xd3, 0x9d, 0x0d, 0x3d, 0x3f, 0x70, 0x6d, 0xf1,
	0x2a, 0xf0, 0xfb, 0xc9, 0x9a, 0x71, 0xe9, 0xc9, 0x38, 0xe9, 0x72, 0x23, 0xad, 0x45, 0x64, 0xb1,
	0xc4, 0x5f, 0x40, 0xed, 0x7e, 0x3e, 0x64, 0x17, 0x20, 0x72, 0x2e, 0xfe, 0x90, 0x73, 0x55, 0x70,
	0x23, 0x5f, 0x56, 0x7b, 0xdf, 0x65, 0xbe, 0x6c, 0x9b, 0xf5, 0xd2, 0xa1, 0x74, 0x9c, 0xa5, 0x20,
	0x20, 0x6b, 0x3c, 0x75, 0xf1, 0xaf, 0xa1, 0xc8, 0x57, 0x9e, 0x5f, 0x2f, 0x73, 0xd9, 0x97, 0x2b,
	0xb2, 0xa6, 0xeb, 0x8f, 0x9d, 0xc9, 0xf8, 0x4f, 0xee, 0xb0, 0xc3, 0x1f, 0x3b, 0x1a, 0xf3, 0x99,
	0xab, 0x33, 0x1c, 0xfa, 0x6e, 0x10, 0xd4, 0xe1, 0x27, 0xba, 0x46, 0xfc, 0xa3, 0xdf, 0x26, 0xef,
	0x4e, 0x7b, 0x1c, 0x84, 0xf8, 0x84, 0x5d, 0x31, 0xb1, 0x0e, 0x56, 0x5b, 0x29, 0x26, 0xd2, 0x84,
	0xd2, 0xf8, 0xbf, 0x94, 0x08, 0xf0, 0x3b, 0x7a, 0x08, 0x2f, 0xcc, 0x1b, 0xd3, 0x22, 0x1d, 0x5b,
	0x31, 0x74, 0x8b, 0xca, 0x8a, 0x65, 0x2b, 0x2d, 0x59, 0xd3, 0xd9, 0xf2, 0x42, 0x6b, 0xa2, 0x0d,
	0xfc, 0x0c, 0xf6, 0x56, 0x19, 0xaf, 0x7b, 0x84, 0xde, 0x20, 0x09, 0xbf, 0x84, 0xfd, 0x35, 0x67,
	0x42, 0x2d, 0xbb, 0x23, 0xeb, 0x72, 0x93, 0xa0, 0x0c, 0x3e, 0x80, 0xe7, 0xab, 0x84, 0xa6, 0xd1,
	0x27, 0x54, 0x97, 0x75, 0x85, 0xa0, 0xec, 0x63, 0xf6, 0x4e, 0xaf, 0x6d, 0x69, 0xb6, 0xa9, 0x35,
	0x75, 0x94, 0x7b, 0x2c, 0xb6, 0x69, 0xc9, 0x16, 0x41, 0x79, 0xfc, 0x29, 0xbc, 0x5c, 0x35, 0x75,
	0xa9, 0xd6, 0x97, 0x2d, 0x62, 0x2b, 0x46, 0xa7, 0xdb, 0xb3, 0x08, 0x2a, 0x34, 0xbe, 0xc9, 0x41,
	0xed, 0xf5, 0xbd, 0xeb, 0x3f, 0x5c, 0xdc, 0xcf, 0xc4, 0x0b, 0xfa, 0x04, 0x70, 0x93, 0x58, 0xf6,
	0x79, 0xdb, 0x50, 0x2e, 0xed, 0xf3, 0x1b, 0xdb, 0xba, 0xb6, 0x35, 0x15, 0x6d, 0xe0, 0x3d, 0xd8,
	0x66, 0xf8, 0x42, 0x4b, 0xd3, 0x2f, 0x0c, 0x24, 0xe1, 0x1d, 0xd8, 0x62, 0xb0, 0x75, 0x9d, 0x70,
	0x33, 0xf8, 0x29, 0xec, 0x2c, 0x69, 0xb4, 0x88, 0xd6, 0x6c, 0x59, 0x28, 0x8b, 0x31, 0x6c, 0x72,
	0x11, 0x5e, 0x40, 0xae, 0xc0, 0xb7, 0xc0, 0xb0, 0xb6, 0x6c, 0x5a, 0x51, 0x4d, 0x85, 0x23, 0xca,
	0xc7, 0x31, 0x13, 0x1d, 0xd9, 0x6c, 0xa1, 0x42, 0x2c, 0xaf, 0x1b, 0x2a, 0x89, 0xa4, 0xda, 0x9a,
	0x69, 0xa1, 0x22, 0xde, 0x87, 0xa7, 0xcc, 0x90, 0x54, 0x70, 0x91, 0x2e, 0x2a, 0xe1, 0x5f, 0xc0,
	0xcf, 0x12, 0xb1, 0x2b, 0xcd, 0x6a, 0xd9, 0xd6, 0x35, 0xbd, 0x32, 0x89, 0x65, 0xa6, 0x52, 0x2c,
	0xb3, 0xb2, 0xfd, 0x10, 0x8d, 0x65, 0x00, 0xf1, 0x3e, 0x78, 0xce, 0x22, 0xd9, 0x0a, 0x7e, 0x01,
	0x75, 0x86, 0x5d, 0xf4, 0xda, 0xed, 0xb5, 0x9d, 0x57, 0xf1, 0x27, 0xf0, 0x2c, 0x91, 0x15, 0x68,
	0x52, 0xb1, 0x5a, 0xec, 0xbc, 0x6a, 0xe6, 0xe1, 0x36, 0xd9, 0x2d, 0x48, 0x5b, 0x65, 0x95, 0xd0,
	0x94, 0xf8, 0x56, 0x2c, 0x2e, 0x53, 0xa5, 0xa5, 0xf5, 0x89, 0xba, 0x24, 0x83, 0x50, 0x5c, 0xe1,
	0xc5, 0xd1, 0x9d, 0xdf, 0x58, 0x44, 0x31, 0x54, 0x82, 0xb6, 0xe3, 0x0a, 0xcb, 0xed, 0xf6, 0xc2,
	0x6c, 0x22, 0xdc, 0xf0, 0xa0, 0x92, 0x1a, 0x66, 0xb8, 0x02, 0x45, 0x4d, 0xef, 0xcb, 0x6d, 0x7e,
	0x11, 0x00, 0x0a, 0xba, 0x6c, 0x69, 0x7d, 0x82, 0x24, 0xf6, 0xfb, 0x4a, 0x36, 0x3b, 0x84, 0xa2,
	0x0c, 0x2e, 0x41, 0xee, 0xea, 0xba, 0xdf, 0x41, 0x59, 0xf6, 0xab, 0x29, 0x9b, 0x1d, 0x94, 0xc3,
	0x45, 0xc8, 0x92, 0x7e, 0x07, 0xe5, 0x71, 0x0d, 0xca, 0xaa, 0xa1, 0x5c, 0x12, 0x6a, 0x37, 0x0d,
	0x54, 0xc0, 0x5b, 0x50, 0x89, 0x96, 0xbf, 0x97, 0xfb, 0x32, 0x2a, 0x36, 0xfe, 0x97, 0x85, 0x4d,
	0xc5, 0x9b, 0xbd, 0x1d, 0x8f, 0x16, 0x17, 0x71, 0x17, 0x50, 0x72, 0x57, 0x16, 0xcd, 0x16, 0x9d,
	0x7d, 0x1a, 0xb5, 0x65, 0x0b, 0x49, 0x4c, 0x52, 0x31, 0x28, 0xb1, 0x7b, 0x5d, 0x95, 0xdd, 0xff,
	0x0c, 0x46, 0x50, 0x15, 0x75, 0x88, 0x10, 0x7e, 0xfb, 0x2c, 0xda, 0x33, 0x2d, 0x9b, 0x1a, 0x86,
	0x65, 0xcb, 0xaa, 0x8a, 0x72, 0xac, 0x00, 0x29, 0x2c, 0xa2, 0xe6, 0x57, 0x60, 0x95, 0xb4, 0x09,
	0x6b, 0x17, 0xbc, 0x0d, 0x35, 0x7e, 0xeb, 0x64, 0x55, 0xa5, 0x5c, 0xa0, 0xc8, 0xd2, 0x4c, 0xa0,
	0xc8, 0xbf, 0xb4, 0x8c, 0x46, 0xee, 0x65, 0x96, 0x12, 0x47, 0x0d, 0xda, 0xe4, 0xde, 0xc0, 0xda,
	0x67, 0x81, 0x44, 0xce, 0x95, 0x25, 0x30, 0xf2, 0xad, 0xb2, 0x8c, 0x14, 0x43, 0x37, 0x89, 0x6e,
	0xf6, 0x4c, 0x9b, 0x5c, 0x8b, 0xfc, 0x6b, 0xb8, 0x0e, 0xbb, 0xcb, 0x70, 0xa4, 0xb2, 0xb9, 0x6e,
	0x89, 0xa4, 0xb6, 0x58, 0x1d, 0xba, 0x84, 0x76, 0x34, 0xd3, 0xd4, 0x0c, 0x9d, 0xeb, 0x20, 0x26,
	0x9f, 0xc2, 0x22, 0x91, 0xed, 0x15, 0x38, 0x52, 0xc0, 0xac, 0xd8, 0x3c, 0x43, 0x4d, 0xe5, 0xee,
	0x3b, 0x4c, 0x32, 0x06, 0x22, 0xdf, 0xdd, 0x34, 0x16, 0x39, 0xee, 0x35, 0xfe, 0x0c, 0x58, 0x71,
	0xfd, 0xb0, 0xe3, 0xcc, 0x9c, 0x91, 0xbb, 0x38, 0xea, 0x2a, 0x94, 0xf8, 0x58, 0x64, 0x5a, 0x1b,
	0xac, 0x4a, 0x6c, 0x65, 0xc6, 0x5e, 0xe2, 0x6c, 0x39, 0x22, 0xe6, 0x6a, 0x26, 0xa1, 0x5c, 0x50,
	0x42, 0xde, 0x44, 0x67, 0x2b, 0x90, 0x9e, 0x1e, 0x61, 0xb9, 0x84, 0x45, 0x49, 0xdf, 0xb8, 0x24,
	0x28, 0xdf, 0xf8, 0x25, 0x6c, 0x77, 0xee, 0x27, 0xe1, 0x98, 0x7d, 0x1c, 0x2c, 0xa2, 0x17, 0x21,
	0x4b, 0xc9, 0x6b, 0xb4, 0xc1, 0xee, 0x6d, 0xdf, 0xe0, 0x01, 0xcb, 0x90, 0x8f, 0x42, 0x35, 0xfe,
	0x2a, 0xc1, 0x73, 0x91, 0x6e, 0x2f, 0x70, 0xfd, 0xf8, 0x69, 0x58, 0x38, 0x6f, 0x43, 0x4d, 0xd3,
	0xb5, 0xa4, 0xb9, 0xd0, 0x06, 0x3b, 0xfb, 0x5e, 0xb7, 0x49, 0x65, 0x35, 0x35, 0x7e, 0xf8, 0xa0,
	0x14, 0x89, 0x25, 0x60, 0x86, 0x95, 0x37, 0xce, 0x37, 0x81, 0xb3, 0x8c, 0x2b, 0x52, 0x4e, 0xc0,
	0x5c, 0xe3, 0x6f, 0x59, 0x38, 0x58, 0xfe, 0x5c, 0x5c, 0x4b, 0x06, 0x41, 0x35, 0xdd, 0xe8, 0x68,
	0x83, 0x55, 0x96, 0x21, 0xaa, 0x6c, 0xc9, 0x48, 0x62, 0x76, 0x53, 0xee, 0x13, 0x5b, 0x91, 0xf9,
	0x33, 0x84, 0x32, 0xcc, 0xce, 0x11, 0x55, 0xa3, 0x28, 0xcb, 0xba, 0x54, 0xac, 0x18, 0x3d, 0xc7,
	0x7a, 0x8d, 0x2f, 0x89, 0xae, 0xb4, 0xd9, 0x5f, 0x4a, 0xba, 0x06, 0xb5, 0x92, 0xb9, 0x1c, 0xe3,
	0x5d, 0x6a, 0x18, 0x17, 0xa2, 0xab, 0x79, 0xf8, 0x48, 0xbd, 0xc8, 0xe6, 0x06, 0x8f, 0xae, 0x51,
	0x54, 0xc2, 0xcf, 0xe1, 0x89, 0xd2, 0x22, 0xca, 0xa5, 0xad, 0xc8, 0xed, 0x36, 0xa1, 0xe2, 0x21,
	0x94, 0x7b, 0x56, 0x0b, 0x95, 0xd9, 0x3b, 0x99, 0x16, 0x24, 0xba, 0x42, 0x6f, 0xba, 0x96, 0xdd,
	0xed, 0x9d, 0xdb, 0x97, 0xe4, 0x06, 0x01, 0xfe, 0x39, 0x1c, 0xa6, 0x09, 0x7d, 0x42, 0xb5, 0x0b,
	0x4d, 0x91, 0x2d, 0x76, 0x2b, 0x63, 0x56, 0x25, 0x7e, 0xbb, 0x56, 0xf2, 0xad, 0xc6, 0x03, 0x30,
	0xc6, 0x95, 0x16, 0xcb, 0x40, 0x6f, 0x12, 0x54, 0x5b, 0x35, 0xb1, 0x67, 0x55, 0xb6, 0x7a, 0x94,
	0x35, 0xd0, 0x3e, 0x3c, 0x35, 0x85, 0x4c, 0xc7, 0xb0, 0x88, 0x2d, 0x5b, 0x16, 0x61, 0x6f, 0xab,
	0x66, 0xe8, 0x68, 0xab, 0x71, 0xce, 0xe7, 0x55, 0xea, 0xe3, 0x8d, 0x6d, 0xb6, 0xa7, 0x5f, 0xea,
	0xc6, 0x95, 0x1e, 0x0d, 0x49, 0x83, 0x76, 0xe4, 0xb6, 0x18, 0x92, 0x17, 0xd4, 0x78, 0x43, 0x74,
	0x94, 0x61, 0x24, 0x71, 0xb2, 0x2a, 0xca, 0x36, 0xe4, 0xe4, 0x53, 0x83, 0x8f, 0xd9, 0x2a, 0x94,
	0xba, 0x32, 0x65, 0xb9, 0xb5, 0x85, 0x84, 0x49, 0xa8, 0xc6, 0x25, 0x2a, 0x50, 0x24, 0xba, 0x6a,
	0x50, 0x93, 0x0d, 0x36, 0x66, 0xd0, 0xf4, 0x66, 0x9b, 0xa0, 0xdc, 0xf9, 0xdb, 0x7f, 0xbd, 0x3f,
	0x90, 0xbe, 0x7d, 0x7f, 0x20, 0xfd, 0xf7, 0xfd, 0x81, 0xf4, 0x8f, 0x0f, 0x07, 0x1b, 0xdf, 0x7e,
	0x38, 0xd8, 0xf8, 0xf7, 0x87, 0x83, 0x0d, 0xa8, 0x7b, 0xfe, 0xe8, 0x64, 0x70, 0xe7, 0x8c, 0x67,
	0x53, 0xe7, 0x4b, 0xd7, 0x3f, 0x99, 0xdf, 0x46, 0x9f, 0x3d, 0x6f, 0xce, 0x52, 0xa8, 0xe7, 0x8f,
	0x4e, 0x93, 0xe5, 0xab, 0x60, 0xf8, 0xe5, 0xab, 0x91, 0x77, 0x3a, 0xbf, 0x3d, 0xe5, 0xff, 0x5c,
	0x18, 0x79, 0xa7, 0xc2, 0xe7, 0xb6, 0xc0, 0xd7, 0x9f, 0x7f, 0x17, 0x00, 0x00, 0xff, 0xff, 0xf9,
	0x75, 0x49, 0xcd, 0xc5, 0x10, 0x00, 0x00,
}

func (m *ContractId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuntimeType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.RuntimeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for iNdEx := len(m.ContractTransaction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContractTransaction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContractTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContractId != nil {
		{
			size, err := m.ContractId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteAttestationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteAttestationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteAttestationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignPair) > 0 {
		for iNdEx := len(m.SignPair) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignPair[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteAttestationPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteAttestationPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteAttestationPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrgId) > 0 {
		for iNdEx := len(m.OrgId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrgId[iNdEx])
			copy(dAtA[i:], m.OrgId[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.OrgId[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrivateDeployRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateDeployRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivateDeployRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignPair) > 0 {
		for iNdEx := len(m.SignPair) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignPair[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrgId) > 0 {
		for iNdEx := len(m.OrgId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrgId[iNdEx])
			copy(dAtA[i:], m.OrgId[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.OrgId[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CodeHash) > 0 {
		i -= len(m.CodeHash)
		copy(dAtA[i:], m.CodeHash)
		i = encodeVarintContract(dAtA, i, uint64(len(m.CodeHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SigAlgo) > 0 {
		i -= len(m.SigAlgo)
		copy(dAtA[i:], m.SigAlgo)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SigAlgo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Passwd) > 0 {
		i -= len(m.Passwd)
		copy(dAtA[i:], m.Passwd)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Passwd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PrivateRlpData) > 0 {
		i -= len(m.PrivateRlpData)
		copy(dAtA[i:], m.PrivateRlpData)
		i = encodeVarintContract(dAtA, i, uint64(len(m.PrivateRlpData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CodeBytes) > 0 {
		i -= len(m.CodeBytes)
		copy(dAtA[i:], m.CodeBytes)
		i = encodeVarintContract(dAtA, i, uint64(len(m.CodeBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrivateComputeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateComputeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivateComputeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignPair) > 0 {
		for iNdEx := len(m.SignPair) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignPair[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrgId) > 0 {
		for iNdEx := len(m.OrgId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrgId[iNdEx])
			copy(dAtA[i:], m.OrgId[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.OrgId[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CodeHash) > 0 {
		i -= len(m.CodeHash)
		copy(dAtA[i:], m.CodeHash)
		i = encodeVarintContract(dAtA, i, uint64(len(m.CodeHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SigAlgo) > 0 {
		i -= len(m.SigAlgo)
		copy(dAtA[i:], m.SigAlgo)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SigAlgo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Passwd) > 0 {
		i -= len(m.Passwd)
		copy(dAtA[i:], m.Passwd)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Passwd)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrivateRlpData) > 0 {
		i -= len(m.PrivateRlpData)
		copy(dAtA[i:], m.PrivateRlpData)
		i = encodeVarintContract(dAtA, i, uint64(len(m.PrivateRlpData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientSign) > 0 {
		i -= len(m.ClientSign)
		copy(dAtA[i:], m.ClientSign)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ClientSign)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreateTime != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.UpdatePolicy != nil {
		{
			size, err := m.UpdatePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EndorsePolicy != nil {
		{
			size, err := m.EndorsePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.RuntimeType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.RuntimeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintContract(dAtA []byte, offset int, v uint64) int {
	offset -= sovContract(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContractId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RuntimeType != 0 {
		n += 1 + sovContract(uint64(m.RuntimeType))
	}
	return n
}

func (m *ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for _, e := range m.ContractTransaction {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *ContractTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractId != nil {
		l = m.ContractId.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *RemoteAttestationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignPair) > 0 {
		for _, e := range m.SignPair {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *RemoteAttestationPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.OrgId) > 0 {
		for _, s := range m.OrgId {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *PrivateDeployRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignPair) > 0 {
		for _, e := range m.SignPair {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *DeployPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CodeBytes)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.PrivateRlpData)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Passwd)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.SigAlgo)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.CodeHash)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.OrgId) > 0 {
		for _, s := range m.OrgId {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *PrivateComputeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignPair) > 0 {
		for _, e := range m.SignPair {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateRlpData)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Passwd)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.SigAlgo)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.CodeHash)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.OrgId) > 0 {
		for _, s := range m.OrgId {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *SignInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientSign)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RuntimeType != 0 {
		n += 1 + sovContract(uint64(m.RuntimeType))
	}
	if m.Status != 0 {
		n += 1 + sovContract(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovContract(uint64(m.Type))
	}
	if m.EndorsePolicy != nil {
		l = m.EndorsePolicy.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.UpdatePolicy != nil {
		l = m.UpdatePolicy.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovContract(uint64(m.CreateTime))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ContractList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func sovContract(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozContract(x uint64) (n int) {
	return sovContract(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContractId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeType", wireType)
			}
			m.RuntimeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeType |= RuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractTransaction = append(m.ContractTransaction, &ContractTransaction{})
			if err := m.ContractTransaction[len(m.ContractTransaction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractId == nil {
				m.ContractId = &ContractId{}
			}
			if err := m.ContractId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteAttestationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAttestationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAttestationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignPair = append(m.SignPair, &SignInfo{})
			if err := m.SignPair[len(m.SignPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &RemoteAttestationPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteAttestationPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAttestationPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAttestationPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = append(m.OrgId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateDeployRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateDeployRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateDeployRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignPair = append(m.SignPair, &SignInfo{})
			if err := m.SignPair[len(m.SignPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &DeployPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeBytes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeBytes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRlpData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRlpData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = append(m.OrgId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateComputeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateComputeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateComputeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignPair = append(m.SignPair, &SignInfo{})
			if err := m.SignPair[len(m.SignPair)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateRlpData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateRlpData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = append(m.OrgId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeType", wireType)
			}
			m.RuntimeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeType |= RuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ContractStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContractType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndorsePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndorsePolicy == nil {
				m.EndorsePolicy = &accesscontrol.Policy{}
			}
			if err := m.EndorsePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePolicy == nil {
				m.UpdatePolicy = &accesscontrol.Policy{}
			}
			if err := m.UpdatePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &accesscontrol.SerializedMember{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &accesscontrol.SerializedMember{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContract(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContract
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthContract
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupContract
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthContract
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthContract        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContract          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupContract = fmt.Errorf("proto: unexpected end of group")
)
