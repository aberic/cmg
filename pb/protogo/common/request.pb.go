// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/request.proto

package common

import (
	accesscontrol "chainmaker.org/chainmaker-go/pb/protogo/accesscontrol"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// transaction type definition
type TxType int32

const (
	// call a pre created user contract, tx included in block
	TxType_INVOKE_USER_CONTRACT TxType = 0
	// query a pre-created user contract, tx not included in block
	TxType_QUERY_USER_CONTRACT TxType = 1
	// create, upgrade, freeze, unfreeze, revoke a user contract, tx included in block
	TxType_MANAGE_USER_CONTRACT TxType = 2
	// call a system contract, tx included in block
	TxType_INVOKE_SYSTEM_CONTRACT TxType = 7
	// query a system contract, tx not included in block
	TxType_QUERY_SYSTEM_CONTRACT TxType = 3
	// update chain config, tx included in block
	TxType_UPDATE_CHAIN_CONFIG TxType = 4
	// subscribe block info, tx not included in block
	TxType_SUBSCRIBE_BLOCK_INFO TxType = 5
	// subscribe tx info, tx not included in block
	TxType_SUBSCRIBE_TX_INFO TxType = 6
)

var TxType_name = map[int32]string{
	0: "INVOKE_USER_CONTRACT",
	1: "QUERY_USER_CONTRACT",
	2: "MANAGE_USER_CONTRACT",
	7: "INVOKE_SYSTEM_CONTRACT",
	3: "QUERY_SYSTEM_CONTRACT",
	4: "UPDATE_CHAIN_CONFIG",
	5: "SUBSCRIBE_BLOCK_INFO",
	6: "SUBSCRIBE_TX_INFO",
}

var TxType_value = map[string]int32{
	"INVOKE_USER_CONTRACT":   0,
	"QUERY_USER_CONTRACT":    1,
	"MANAGE_USER_CONTRACT":   2,
	"INVOKE_SYSTEM_CONTRACT": 7,
	"QUERY_SYSTEM_CONTRACT":  3,
	"UPDATE_CHAIN_CONFIG":    4,
	"SUBSCRIBE_BLOCK_INFO":   5,
	"SUBSCRIBE_TX_INFO":      6,
}

func (x TxType) String() string {
	return proto.EnumName(TxType_name, int32(x))
}

func (TxType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{0}
}

// transaction request proposed by user
type TxRequest struct {
	// header of the request
	Header *TxHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// payload of the request, can be unmarshalled according to tx_type in header
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// signature of [header bytes || payload bytes]
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *TxRequest) Reset()         { *m = TxRequest{} }
func (m *TxRequest) String() string { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()    {}
func (*TxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{0}
}
func (m *TxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest.Merge(m, src)
}
func (m *TxRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest proto.InternalMessageInfo

func (m *TxRequest) GetHeader() *TxHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TxRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TxRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// header of the request
type TxHeader struct {
	// blockchain identifier
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// sender identifier
	Sender *accesscontrol.SerializedMember `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// transaction type
	TxType TxType `protobuf:"varint,3,opt,name=tx_type,json=txType,proto3,enum=common.TxType" json:"tx_type,omitempty"`
	// transaction id set by sender, should be unique
	TxId string `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	// transaction timestamp, in unix timestamp format, seconds
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// expiration timestamp in unix timestamp format
	// after that the transaction is invalid if it is not included in block yet
	ExpirationTime int64 `protobuf:"varint,6,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
}

func (m *TxHeader) Reset()         { *m = TxHeader{} }
func (m *TxHeader) String() string { return proto.CompactTextString(m) }
func (*TxHeader) ProtoMessage()    {}
func (*TxHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{1}
}
func (m *TxHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxHeader.Merge(m, src)
}
func (m *TxHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxHeader proto.InternalMessageInfo

func (m *TxHeader) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TxHeader) GetSender() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *TxHeader) GetTxType() TxType {
	if m != nil {
		return m.TxType
	}
	return TxType_INVOKE_USER_CONTRACT
}

func (m *TxHeader) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxHeader) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TxHeader) GetExpirationTime() int64 {
	if m != nil {
		return m.ExpirationTime
	}
	return 0
}

// query type transaction payload
// TxType: QUERY_USER_CONTRACT & QUERY_SYSTEM_CONTRACT
type QueryPayload struct {
	// smart contract name
	ContractName string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// query method
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// query parameters in k-v format
	Parameters []*KeyValuePair `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty"`
}

func (m *QueryPayload) Reset()         { *m = QueryPayload{} }
func (m *QueryPayload) String() string { return proto.CompactTextString(m) }
func (*QueryPayload) ProtoMessage()    {}
func (*QueryPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{2}
}
func (m *QueryPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPayload.Merge(m, src)
}
func (m *QueryPayload) XXX_Size() int {
	return m.Size()
}
func (m *QueryPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPayload.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPayload proto.InternalMessageInfo

func (m *QueryPayload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *QueryPayload) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *QueryPayload) GetParameters() []*KeyValuePair {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// transact type transaction payload
// TxType: INVOKE_USER_CONTRACT
type TransactPayload struct {
	// smart contract name
	ContractName string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// invoke method
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// invoke parameters in k-v format
	Parameters []*KeyValuePair `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty"`
}

func (m *TransactPayload) Reset()         { *m = TransactPayload{} }
func (m *TransactPayload) String() string { return proto.CompactTextString(m) }
func (*TransactPayload) ProtoMessage()    {}
func (*TransactPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{3}
}
func (m *TransactPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactPayload.Merge(m, src)
}
func (m *TransactPayload) XXX_Size() int {
	return m.Size()
}
func (m *TransactPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactPayload.DiscardUnknown(m)
}

var xxx_messageInfo_TransactPayload proto.InternalMessageInfo

func (m *TransactPayload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *TransactPayload) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *TransactPayload) GetParameters() []*KeyValuePair {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// config update type transaction payload
// TxType: UPDATE_CHAIN_CONFIG
type SystemContractPayload struct {
	// endorsement signature with chain_id, redundant with TxHeader
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// smart contract name
	ContractName string `protobuf:"bytes,2,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// update method
	Method string `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	// update parameters in k-v format
	Parameters []*KeyValuePair `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty"`
	// config sequence, starts from 0 (genesis config)
	Sequence uint64 `protobuf:"varint,5,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// multi-sign, signature of [SystemContractPayload] with endorsement = nil
	Endorsement []*EndorsementEntry `protobuf:"bytes,6,rep,name=endorsement,proto3" json:"endorsement,omitempty"`
}

func (m *SystemContractPayload) Reset()         { *m = SystemContractPayload{} }
func (m *SystemContractPayload) String() string { return proto.CompactTextString(m) }
func (*SystemContractPayload) ProtoMessage()    {}
func (*SystemContractPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{4}
}
func (m *SystemContractPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemContractPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemContractPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemContractPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemContractPayload.Merge(m, src)
}
func (m *SystemContractPayload) XXX_Size() int {
	return m.Size()
}
func (m *SystemContractPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemContractPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SystemContractPayload proto.InternalMessageInfo

func (m *SystemContractPayload) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SystemContractPayload) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *SystemContractPayload) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *SystemContractPayload) GetParameters() []*KeyValuePair {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *SystemContractPayload) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *SystemContractPayload) GetEndorsement() []*EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

// contract management type transaction payload
// TxType: MANAGE_USER_CONTRACT
type ContractMgmtPayload struct {
	// endorsement signature with chain_id, redundant with TxHeader
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// smart contract id
	ContractId *ContractId `protobuf:"bytes,2,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// contract management method, see ManageUserContractFunction
	Method string `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	// parameters in k-v format
	Parameters []*KeyValuePair `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty"`
	// compiled byte code
	ByteCode []byte `protobuf:"bytes,5,opt,name=byte_code,json=byteCode,proto3" json:"byte_code,omitempty"`
	// multi-sign, signature of [ContractMgmtPayload] with endorsement = nil
	Endorsement []*EndorsementEntry `protobuf:"bytes,6,rep,name=endorsement,proto3" json:"endorsement,omitempty"`
}

func (m *ContractMgmtPayload) Reset()         { *m = ContractMgmtPayload{} }
func (m *ContractMgmtPayload) String() string { return proto.CompactTextString(m) }
func (*ContractMgmtPayload) ProtoMessage()    {}
func (*ContractMgmtPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{5}
}
func (m *ContractMgmtPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMgmtPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMgmtPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMgmtPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMgmtPayload.Merge(m, src)
}
func (m *ContractMgmtPayload) XXX_Size() int {
	return m.Size()
}
func (m *ContractMgmtPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMgmtPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMgmtPayload proto.InternalMessageInfo

func (m *ContractMgmtPayload) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ContractMgmtPayload) GetContractId() *ContractId {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *ContractMgmtPayload) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ContractMgmtPayload) GetParameters() []*KeyValuePair {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ContractMgmtPayload) GetByteCode() []byte {
	if m != nil {
		return m.ByteCode
	}
	return nil
}

func (m *ContractMgmtPayload) GetEndorsement() []*EndorsementEntry {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

// endorsement info, including a signer and his signature
type EndorsementEntry struct {
	Signer    *accesscontrol.SerializedMember `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Signature []byte                          `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *EndorsementEntry) Reset()         { *m = EndorsementEntry{} }
func (m *EndorsementEntry) String() string { return proto.CompactTextString(m) }
func (*EndorsementEntry) ProtoMessage()    {}
func (*EndorsementEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{6}
}
func (m *EndorsementEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndorsementEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndorsementEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndorsementEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndorsementEntry.Merge(m, src)
}
func (m *EndorsementEntry) XXX_Size() int {
	return m.Size()
}
func (m *EndorsementEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_EndorsementEntry.DiscardUnknown(m)
}

var xxx_messageInfo_EndorsementEntry proto.InternalMessageInfo

func (m *EndorsementEntry) GetSigner() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *EndorsementEntry) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// a k-v pair
type KeyValuePair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KeyValuePair) Reset()         { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()    {}
func (*KeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{7}
}
func (m *KeyValuePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValuePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValuePair.Merge(m, src)
}
func (m *KeyValuePair) XXX_Size() int {
	return m.Size()
}
func (m *KeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValuePair proto.InternalMessageInfo

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// subscribe block type transaction payload
// TxType: SUBSCRIBE_BLOCK_INFO
type SubscribeBlockPayload struct {
	// start block height:
	// < -1: invalid
	// == -1: subscribe with latest block
	// >= 0：starts with the block height
	StartBlock int64 `protobuf:"varint,1,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	// end block height:
	// < -1: invalid
	// == -1: subscribe with latest block
	// >= 0：ends with the block height
	EndBlock int64 `protobuf:"varint,2,opt,name=end_block,json=endBlock,proto3" json:"end_block,omitempty"`
	// include rw set in block or not
	WithRwSet bool `protobuf:"varint,3,opt,name=with_rw_set,json=withRwSet,proto3" json:"with_rw_set,omitempty"`
}

func (m *SubscribeBlockPayload) Reset()         { *m = SubscribeBlockPayload{} }
func (m *SubscribeBlockPayload) String() string { return proto.CompactTextString(m) }
func (*SubscribeBlockPayload) ProtoMessage()    {}
func (*SubscribeBlockPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{8}
}
func (m *SubscribeBlockPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeBlockPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeBlockPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeBlockPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeBlockPayload.Merge(m, src)
}
func (m *SubscribeBlockPayload) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeBlockPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeBlockPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeBlockPayload proto.InternalMessageInfo

func (m *SubscribeBlockPayload) GetStartBlock() int64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *SubscribeBlockPayload) GetEndBlock() int64 {
	if m != nil {
		return m.EndBlock
	}
	return 0
}

func (m *SubscribeBlockPayload) GetWithRwSet() bool {
	if m != nil {
		return m.WithRwSet
	}
	return false
}

// subscribe transaction type transaction payload
// TxType: SUBSCRIBE_TX_INFO
type SubscribeTxPayload struct {
	// start block height:
	// < -1: invalid
	// == -1: subscribe with latest block
	// >= 0：starts with the block height
	StartBlock int64 `protobuf:"varint,1,opt,name=start_block,json=startBlock,proto3" json:"start_block,omitempty"`
	// end block height:
	// < -1: invalid
	// == -1: subscribe with latest block
	// >= 0：ends with the block height
	EndBlock int64 `protobuf:"varint,2,opt,name=end_block,json=endBlock,proto3" json:"end_block,omitempty"`
	// subscribe this type only
	// if null, subscribe all transaction types
	TxType TxType `protobuf:"varint,3,opt,name=tx_type,json=txType,proto3,enum=common.TxType" json:"tx_type,omitempty"`
	// subscribe these transaction ids only
	// if null, subscribe all transactions
	TxIds []string `protobuf:"bytes,4,rep,name=tx_ids,json=txIds,proto3" json:"tx_ids,omitempty"`
}

func (m *SubscribeTxPayload) Reset()         { *m = SubscribeTxPayload{} }
func (m *SubscribeTxPayload) String() string { return proto.CompactTextString(m) }
func (*SubscribeTxPayload) ProtoMessage()    {}
func (*SubscribeTxPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c88414c8dcc4a967, []int{9}
}
func (m *SubscribeTxPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeTxPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeTxPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeTxPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeTxPayload.Merge(m, src)
}
func (m *SubscribeTxPayload) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeTxPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeTxPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeTxPayload proto.InternalMessageInfo

func (m *SubscribeTxPayload) GetStartBlock() int64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *SubscribeTxPayload) GetEndBlock() int64 {
	if m != nil {
		return m.EndBlock
	}
	return 0
}

func (m *SubscribeTxPayload) GetTxType() TxType {
	if m != nil {
		return m.TxType
	}
	return TxType_INVOKE_USER_CONTRACT
}

func (m *SubscribeTxPayload) GetTxIds() []string {
	if m != nil {
		return m.TxIds
	}
	return nil
}

func init() {
	proto.RegisterEnum("common.TxType", TxType_name, TxType_value)
	proto.RegisterType((*TxRequest)(nil), "common.TxRequest")
	proto.RegisterType((*TxHeader)(nil), "common.TxHeader")
	proto.RegisterType((*QueryPayload)(nil), "common.QueryPayload")
	proto.RegisterType((*TransactPayload)(nil), "common.TransactPayload")
	proto.RegisterType((*SystemContractPayload)(nil), "common.SystemContractPayload")
	proto.RegisterType((*ContractMgmtPayload)(nil), "common.ContractMgmtPayload")
	proto.RegisterType((*EndorsementEntry)(nil), "common.EndorsementEntry")
	proto.RegisterType((*KeyValuePair)(nil), "common.KeyValuePair")
	proto.RegisterType((*SubscribeBlockPayload)(nil), "common.SubscribeBlockPayload")
	proto.RegisterType((*SubscribeTxPayload)(nil), "common.SubscribeTxPayload")
}

func init() { proto.RegisterFile("common/request.proto", fileDescriptor_c88414c8dcc4a967) }

var fileDescriptor_c88414c8dcc4a967 = []byte{
	// 851 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0xcf, 0x6f, 0xe3, 0x54,
	0x10, 0xae, 0xf3, 0xc3, 0x4d, 0x26, 0xa1, 0x1b, 0x5e, 0x9b, 0xc5, 0x1b, 0x50, 0xb6, 0x0a, 0x87,
	0x8d, 0x90, 0x48, 0xa4, 0x2e, 0x02, 0x89, 0x5b, 0x12, 0xb2, 0xbb, 0x51, 0x69, 0xda, 0x7d, 0x76,
	0x57, 0x2c, 0x17, 0xeb, 0xd9, 0x1e, 0xa5, 0x56, 0x63, 0xbf, 0xf0, 0xfc, 0x42, 0x63, 0x6e, 0x48,
	0x1c, 0x39, 0x20, 0xfe, 0x2a, 0x8e, 0x7b, 0x42, 0x1c, 0x51, 0xfb, 0x77, 0x20, 0x21, 0x3f, 0xdb,
	0x49, 0x37, 0x48, 0x55, 0x25, 0x56, 0xda, 0x53, 0x32, 0xdf, 0x37, 0x9e, 0x6f, 0x7e, 0x78, 0xc6,
	0x70, 0xe0, 0xf2, 0x20, 0xe0, 0x61, 0x5f, 0xe0, 0x0f, 0x4b, 0x8c, 0x64, 0x6f, 0x21, 0xb8, 0xe4,
	0x44, 0x4f, 0xd1, 0x56, 0x33, 0x63, 0x5d, 0x1e, 0x4a, 0xc1, 0xdc, 0x8c, 0x6e, 0xb5, 0x98, 0xeb,
	0x62, 0x14, 0x29, 0x94, 0xcf, 0xfb, 0x01, 0x06, 0x0e, 0x8a, 0x94, 0xeb, 0x04, 0x50, 0xb5, 0x56,
	0x34, 0x8d, 0x46, 0xba, 0xa0, 0x5f, 0x20, 0xf3, 0x50, 0x18, 0xda, 0xa1, 0xd6, 0xad, 0x1d, 0x35,
	0x7a, 0x69, 0xc0, 0x9e, 0xb5, 0x7a, 0xa1, 0x70, 0x9a, 0xf1, 0xc4, 0x80, 0xdd, 0x05, 0x8b, 0xe7,
	0x9c, 0x79, 0x46, 0xe1, 0x50, 0xeb, 0xd6, 0x69, 0x6e, 0x92, 0x4f, 0xa0, 0x1a, 0xf9, 0xb3, 0x90,
	0xc9, 0xa5, 0x40, 0xa3, 0xa8, 0xb8, 0x0d, 0xd0, 0xb9, 0xd1, 0xa0, 0x92, 0x07, 0x23, 0x8f, 0xa0,
	0xe2, 0x5e, 0x30, 0x3f, 0xb4, 0x7d, 0x4f, 0x09, 0x56, 0xe9, 0xae, 0xb2, 0x27, 0x1e, 0xf9, 0x0a,
	0xf4, 0x08, 0xc3, 0x24, 0x93, 0x82, 0xca, 0xe4, 0x71, 0xef, 0xad, 0x1a, 0x7a, 0x26, 0x0a, 0x9f,
	0xcd, 0xfd, 0x9f, 0xd0, 0x3b, 0x51, 0xd5, 0xd0, 0xcc, 0x9d, 0x3c, 0x81, 0x5d, 0xb9, 0xb2, 0x65,
	0xbc, 0x48, 0xc5, 0xf7, 0x8e, 0xf6, 0x36, 0x35, 0x58, 0xf1, 0x02, 0xa9, 0x2e, 0xd5, 0x2f, 0xd9,
	0x87, 0xb2, 0x5c, 0x25, 0xca, 0x25, 0xa5, 0x5c, 0x92, 0xab, 0x89, 0x4a, 0x5e, 0xfa, 0x01, 0x46,
	0x92, 0x05, 0x0b, 0xa3, 0x7c, 0xa8, 0x75, 0x8b, 0x74, 0x03, 0x90, 0x27, 0xf0, 0x00, 0x57, 0x0b,
	0x5f, 0x30, 0xe9, 0xf3, 0xd0, 0x4e, 0x70, 0x43, 0x57, 0x3e, 0x7b, 0x1b, 0xd8, 0xf2, 0x03, 0xec,
	0xfc, 0xac, 0x41, 0xfd, 0xe5, 0x12, 0x45, 0x7c, 0x96, 0x35, 0xe5, 0x53, 0xf8, 0x20, 0x9f, 0x89,
	0x1d, 0xb2, 0x00, 0xb3, 0x72, 0xeb, 0x39, 0x38, 0x65, 0x01, 0x92, 0x87, 0xa0, 0x07, 0x28, 0x2f,
	0x78, 0xda, 0xd2, 0x2a, 0xcd, 0x2c, 0xf2, 0x05, 0xc0, 0x82, 0x09, 0x16, 0xa0, 0x44, 0x11, 0x19,
	0xc5, 0xc3, 0x62, 0xb7, 0x76, 0x74, 0x90, 0x57, 0x75, 0x8c, 0xf1, 0x2b, 0x36, 0x5f, 0xe2, 0x19,
	0xf3, 0x05, 0xbd, 0xe5, 0xd7, 0xf9, 0x45, 0x83, 0x07, 0x96, 0x60, 0x61, 0xc4, 0x5c, 0xf9, 0x1e,
	0xd3, 0xf8, 0x47, 0x83, 0xa6, 0x19, 0x47, 0x12, 0x83, 0x51, 0x26, 0x92, 0x27, 0x73, 0xc7, 0xf4,
	0xff, 0x93, 0x67, 0xe1, 0xce, 0x3c, 0x8b, 0x77, 0xe4, 0x59, 0xba, 0x5f, 0x9e, 0xa4, 0x05, 0x95,
	0x28, 0xd9, 0x82, 0xd0, 0x45, 0x35, 0xf8, 0x12, 0x5d, 0xdb, 0xe4, 0x6b, 0xa8, 0x61, 0xe8, 0x71,
	0x11, 0x61, 0x80, 0xa1, 0x34, 0x74, 0x15, 0xd2, 0xc8, 0x43, 0x8e, 0x37, 0xd4, 0x38, 0x94, 0x22,
	0xa6, 0xb7, 0x9d, 0x3b, 0xbf, 0x16, 0x60, 0x3f, 0xaf, 0xfc, 0x64, 0x16, 0xdc, 0xa7, 0xfa, 0xa7,
	0x50, 0x5b, 0x57, 0xef, 0x7b, 0xd9, 0x02, 0x90, 0x5c, 0x2e, 0x0f, 0x36, 0xf1, 0x28, 0xb8, 0xeb,
	0xff, 0xef, 0xb8, 0x1b, 0x1f, 0x43, 0xd5, 0x89, 0x25, 0xda, 0x2e, 0xf7, 0xd2, 0x76, 0xd4, 0x69,
	0x25, 0x01, 0x46, 0xdc, 0xfb, 0x7f, 0xed, 0xf0, 0xa1, 0xb1, 0xed, 0xa0, 0x76, 0xdd, 0x9f, 0x85,
	0xeb, 0xab, 0x73, 0x8f, 0x5d, 0x57, 0xee, 0x6f, 0x9f, 0x9a, 0xc2, 0xf6, 0xa9, 0xf9, 0x12, 0xea,
	0xb7, 0xeb, 0x23, 0x0d, 0x28, 0x5e, 0x62, 0x9c, 0x35, 0x3b, 0xf9, 0x4b, 0x0e, 0xa0, 0xfc, 0x63,
	0x42, 0x67, 0xaf, 0x57, 0x6a, 0x74, 0x96, 0xd0, 0x34, 0x97, 0x4e, 0xe4, 0x0a, 0xdf, 0xc1, 0xe1,
	0x9c, 0xbb, 0x97, 0xf9, 0xc8, 0x1e, 0x43, 0x2d, 0x92, 0x4c, 0x48, 0xdb, 0x49, 0x50, 0x15, 0xa8,
	0x48, 0x41, 0x41, 0xca, 0x2f, 0xe9, 0x1a, 0x86, 0x5e, 0x46, 0x17, 0x14, 0x5d, 0xc1, 0xd0, 0x4b,
	0xc9, 0x36, 0xd4, 0xae, 0x7c, 0x79, 0x61, 0x8b, 0x2b, 0x3b, 0x42, 0xa9, 0xa6, 0x54, 0xa1, 0xd5,
	0x04, 0xa2, 0x57, 0x26, 0xca, 0xce, 0xef, 0x1a, 0x90, 0xb5, 0xae, 0xb5, 0x7a, 0x37, 0xa2, 0xf7,
	0xbe, 0x86, 0x4d, 0xd0, 0xd5, 0x35, 0x4c, 0x5f, 0x91, 0x2a, 0x2d, 0x27, 0xe7, 0x30, 0xfa, 0xec,
	0x4f, 0x0d, 0xf4, 0xd4, 0x93, 0x18, 0x70, 0x30, 0x99, 0xbe, 0x3a, 0x3d, 0x1e, 0xdb, 0xe7, 0xe6,
	0x98, 0xda, 0xa3, 0xd3, 0xa9, 0x45, 0x07, 0x23, 0xab, 0xb1, 0x43, 0x3e, 0x82, 0xfd, 0x97, 0xe7,
	0x63, 0xfa, 0x7a, 0x8b, 0xd0, 0x92, 0x47, 0x4e, 0x06, 0xd3, 0xc1, 0xf3, 0xed, 0x47, 0x0a, 0xa4,
	0x05, 0x0f, 0xb3, 0x60, 0xe6, 0x6b, 0xd3, 0x1a, 0x9f, 0x6c, 0xb8, 0x5d, 0xf2, 0x08, 0x9a, 0x69,
	0xb8, 0x6d, 0xaa, 0x98, 0x28, 0x9d, 0x9f, 0x7d, 0x33, 0xb0, 0xc6, 0xf6, 0xe8, 0xc5, 0x60, 0x32,
	0x4d, 0xa8, 0x67, 0x93, 0xe7, 0x8d, 0x52, 0xa2, 0x64, 0x9e, 0x0f, 0xcd, 0x11, 0x9d, 0x0c, 0xc7,
	0xf6, 0xf0, 0xdb, 0xd3, 0xd1, 0xb1, 0x3d, 0x99, 0x3e, 0x3b, 0x6d, 0x94, 0x49, 0x13, 0x3e, 0xdc,
	0x30, 0xd6, 0x77, 0x29, 0xac, 0x0f, 0x9d, 0x3f, 0xae, 0xdb, 0xda, 0x9b, 0xeb, 0xb6, 0xf6, 0xf7,
	0x75, 0x5b, 0xfb, 0xed, 0xa6, 0xbd, 0xf3, 0xe6, 0xa6, 0xbd, 0xf3, 0xd7, 0x4d, 0x7b, 0x07, 0x0c,
	0x2e, 0x66, 0x3d, 0xb5, 0x8a, 0x01, 0xbb, 0x4c, 0x3e, 0x93, 0x4e, 0xd6, 0xb2, 0xef, 0x6f, 0xa3,
	0x5c, 0xcc, 0xfa, 0x1b, 0xf3, 0xf3, 0x19, 0xef, 0x2f, 0x9c, 0xbe, 0xfa, 0xa2, 0xce, 0x78, 0x3f,
	0xf5, 0x77, 0x74, 0x65, 0x3f, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0xcc, 0xc7, 0xda, 0xf8, 0xb4,
	0x07, 0x00, 0x00,
}

func (m *TxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRequest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationTime != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.ExpirationTime))
		i--
		dAtA[i] = 0x30
	}
	if m.Timestamp != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x22
	}
	if m.TxType != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.TxType))
		i--
		dAtA[i] = 0x18
	}
	if m.Sender != nil {
		{
			size, err := m.Sender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRequest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemContractPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemContractPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemContractPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endorsement) > 0 {
		for iNdEx := len(m.Endorsement) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endorsement[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Sequence != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractMgmtPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMgmtPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMgmtPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endorsement) > 0 {
		for iNdEx := len(m.Endorsement) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endorsement[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ByteCode) > 0 {
		i -= len(m.ByteCode)
		copy(dAtA[i:], m.ByteCode)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ByteCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRequest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ContractId != nil {
		{
			size, err := m.ContractId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRequest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndorsementEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndorsementEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndorsementEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.Signer != nil {
		{
			size, err := m.Signer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRequest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValuePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValuePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValuePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRequest(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeBlockPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeBlockPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeBlockPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithRwSet {
		i--
		if m.WithRwSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.EndBlock != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.EndBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlock != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.StartBlock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeTxPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeTxPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeTxPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxIds) > 0 {
		for iNdEx := len(m.TxIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TxIds[iNdEx])
			copy(dAtA[i:], m.TxIds[iNdEx])
			i = encodeVarintRequest(dAtA, i, uint64(len(m.TxIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TxType != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.TxType))
		i--
		dAtA[i] = 0x18
	}
	if m.EndBlock != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.EndBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlock != 0 {
		i = encodeVarintRequest(dAtA, i, uint64(m.StartBlock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRequest(dAtA []byte, offset int, v uint64) int {
	offset -= sovRequest(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	return n
}

func (m *TxHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRequest(uint64(l))
	}
	if m.TxType != 0 {
		n += 1 + sovRequest(uint64(m.TxType))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRequest(uint64(m.Timestamp))
	}
	if m.ExpirationTime != 0 {
		n += 1 + sovRequest(uint64(m.ExpirationTime))
	}
	return n
}

func (m *QueryPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	return n
}

func (m *TransactPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	return n
}

func (m *SystemContractPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	if m.Sequence != 0 {
		n += 1 + sovRequest(uint64(m.Sequence))
	}
	if len(m.Endorsement) > 0 {
		for _, e := range m.Endorsement {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	return n
}

func (m *ContractMgmtPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if m.ContractId != nil {
		l = m.ContractId.Size()
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	l = len(m.ByteCode)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	if len(m.Endorsement) > 0 {
		for _, e := range m.Endorsement {
			l = e.Size()
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	return n
}

func (m *EndorsementEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Signer != nil {
		l = m.Signer.Size()
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	return n
}

func (m *KeyValuePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRequest(uint64(l))
	}
	return n
}

func (m *SubscribeBlockPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlock != 0 {
		n += 1 + sovRequest(uint64(m.StartBlock))
	}
	if m.EndBlock != 0 {
		n += 1 + sovRequest(uint64(m.EndBlock))
	}
	if m.WithRwSet {
		n += 2
	}
	return n
}

func (m *SubscribeTxPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlock != 0 {
		n += 1 + sovRequest(uint64(m.StartBlock))
	}
	if m.EndBlock != 0 {
		n += 1 + sovRequest(uint64(m.EndBlock))
	}
	if m.TxType != 0 {
		n += 1 + sovRequest(uint64(m.TxType))
	}
	if len(m.TxIds) > 0 {
		for _, s := range m.TxIds {
			l = len(s)
			n += 1 + l + sovRequest(uint64(l))
		}
	}
	return n
}

func sovRequest(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRequest(x uint64) (n int) {
	return sovRequest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &TxHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &accesscontrol.SerializedMember{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxType", wireType)
			}
			m.TxType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxType |= TxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			m.ExpirationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &KeyValuePair{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &KeyValuePair{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemContractPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemContractPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemContractPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &KeyValuePair{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endorsement = append(m.Endorsement, &EndorsementEntry{})
			if err := m.Endorsement[len(m.Endorsement)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMgmtPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMgmtPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMgmtPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractId == nil {
				m.ContractId = &ContractId{}
			}
			if err := m.ContractId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &KeyValuePair{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteCode = append(m.ByteCode[:0], dAtA[iNdEx:postIndex]...)
			if m.ByteCode == nil {
				m.ByteCode = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endorsement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endorsement = append(m.Endorsement, &EndorsementEntry{})
			if err := m.Endorsement[len(m.Endorsement)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndorsementEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndorsementEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndorsementEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signer == nil {
				m.Signer = &accesscontrol.SerializedMember{}
			}
			if err := m.Signer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValuePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValuePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValuePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeBlockPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeBlockPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeBlockPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			m.EndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithRwSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithRwSet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeTxPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeTxPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeTxPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlock", wireType)
			}
			m.StartBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			m.EndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxType", wireType)
			}
			m.TxType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxType |= TxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRequest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxIds = append(m.TxIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRequest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRequest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRequest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRequest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRequest
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRequest
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRequest
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRequest        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRequest          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRequest = fmt.Errorf("proto: unexpected end of group")
)
